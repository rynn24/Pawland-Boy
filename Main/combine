import pygame
import os
import math
import sys
import random
import time

# Initialise
pygame.init()
screen = pygame.display.set_mode((620, 480))
pygame.display.set_caption("Pawland Boy")
clock = pygame.time.Clock()

font = pygame.font.SysFont(None, 24)

# Load map image
map_image = pygame.image.load(os.path.join("rynn/Map.png")).convert()

# Camera and player position 
camera_width, camera_height = 320, 180
camera = pygame.Rect(0, 0, camera_width, camera_height)
zoom_surface = pygame.Surface((camera_width, camera_height))
player_position = pygame.Vector2(320, 180)
speed = 2
restricted_zones = [
        {
        "type": "ellipse",
        "center": (1554, 585),
        "radius_x": 165,
        "radius_y": 162
        }
    ] 

def is_in_ellipse(point, center, radius_x, radius_y):
    px, py = point
    cx, cy = center
    dx = (px - cx) ** 2 / (radius_x ** 2)
    dy = (py - cy) ** 2 / (radius_y ** 2)
    result = dx + dy <= 1
    return result

def is_in_restricted_zone(point, zones):
    for zone in zones:
        if zone["type"] == "ellipse":
            if is_in_ellipse(point, zone["center"], zone["radius_x"], zone["radius_y"]):
                return True
    return False

# Day-night cycle
overlay = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
time_counter = 0
cycle_speed = (2 * math.pi) / 30

# Minimap settings
minimap_radius = 60
minimap_zoom_factor = 0.8
minimap_pos = (minimap_radius + 10, minimap_radius + 10)
minimap_border_color = (0, 0, 0)
minimap_border_width = 2
player_minimap_color = (255, 50, 50)
minimap_mask = pygame.Surface((minimap_radius * 2, minimap_radius * 2), pygame.SRCALPHA)
pygame.draw.circle(minimap_mask, (255, 255, 255), (minimap_radius, minimap_radius), minimap_radius)

FRAME_WIDTH, FRAME_HEIGHT = 200, 200

def load_frames(sheet, frame_width, frame_height, row, num_frames):
    return [sheet.subsurface(pygame.Rect(i * frame_width, row * frame_height, frame_width, frame_height)) for i in range(num_frames)]

def load_frames_from_sheet(sheet_path, frame_width, frame_height, rows, columns, resize_to=None):
    sheet = pygame.image.load(sheet_path).convert_alpha()
    frames = []

    for row in range(rows):
        row_frames = []
        for col in range(columns):
            x = col * frame_width
            y = row * frame_height
            frame = sheet.subsurface(pygame.Rect(x, y, frame_width, frame_height))
            if resize_to:
                frame = pygame.transform.scale(frame, resize_to)  # resize only if needed
            row_frames.append(frame)
        frames.append(row_frames)
    
    return frames  # e.g., frames[0] = walk, frames[1] = attack

zombie_img = pygame.image.load("haojun/image/zombie.png").convert_alpha()  # <--- STEP 1
zombie_img = pygame.transform.scale(zombie_img, (64, 64))
zombie_attack_images = load_frames_from_sheet("haojun/image/zombie attack.png", 64, 64,1, 4)[0]
zombie_die_images = load_frames_from_sheet("haojun/image/zombie get attack.png", 64, 64,1, 4)[0]
zombie_walk_images =load_frames_from_sheet("haojun/image/zombie walk.png", 64, 64, 1, 5)[0]

class Player:
    def __init__(self, position, speed):
        self.position = position
        self.speed = speed
        self.image = pygame.image.load("minting/character.png").convert_alpha()
        self.rect = self.image.get_rect(center=(400, 300))#detect the collision, help pygame to allocate where is the player
        self.direction = 'down'
        self.attacking = False
        self.frame = 0
        self.attack_frame = 0
        self.last_frame_time = 0
        self.frame_speed = 0.1
        self.attack_frame_delay = 3
        self.attack_frame_counter = 0
        self.weapons = ['hand', 'axe', 'sword']
        self.current_weapon = 'hand'
        self.last_update = pygame.time.get_ticks()
        self.animation_cooldown = 100  # milliseconds between frames
        self.health = 100


        self.walk_sheet = pygame.image.load("minting/character.png").convert_alpha()
        
        self.walk_down = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 0, 3)
        self.walk_up = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 1, 4)
        self.walk_left = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 2, 4)
        self.walk_right = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 3, 4)
       
        self.attack_sheets = {
                'hand': pygame.image.load("minting/hand_attack.png").convert_alpha(),
                'axe': pygame.image.load("minting/axe_attack.png").convert_alpha(),
                'sword': pygame.image.load("minting/sword_attack.png").convert_alpha()
            }
        
        self.attack_frames = {
            'hand': {
                'right': load_frames(self.attack_sheets['hand'], FRAME_WIDTH, FRAME_HEIGHT, 0, 2),
                'left': load_frames(self.attack_sheets['hand'], FRAME_WIDTH, FRAME_HEIGHT, 1, 2)
            },
                'axe': {
                'right': load_frames(self.attack_sheets['axe'], FRAME_WIDTH, FRAME_HEIGHT, 0, 2),
                'left': load_frames(self.attack_sheets['axe'], FRAME_WIDTH, FRAME_HEIGHT, 1, 2)
            },
            'sword': {
                'right': load_frames(self.attack_sheets['sword'], FRAME_WIDTH, FRAME_HEIGHT, 0, 4),
                'left': load_frames(self.attack_sheets['sword'], FRAME_WIDTH, FRAME_HEIGHT, 1, 4)
            }
        }
        
    def move(self, keys, dt):
        move_distance = self.speed * dt 
        moving = False
        direction_vector = pygame.math.Vector2(0, 0)

        

        if self.attacking:
            return new_position, self.get_attack_sprite()  # Prevent movement while attacking
        
        self.rect.center = (self.position.x, self.position.y)

        if keys[pygame.K_w]:
            self.position.y -= move_distance
            self.direction = 'up'
            moving = True
        if keys[pygame.K_s]:
            self.position.y += move_distance
            self.direction = 'down'
            moving = True
        if keys[pygame.K_a]:
            self.position.x -= move_distance
            self.direction = 'left'
            moving = True
        if keys[pygame.K_d]:
            self.position.x += move_distance
            self.direction = 'right'
            moving = True
        
            # Normalize to prevent diagonal speed-up
        if direction_vector.length() != 0:
            direction_vector = direction_vector.normalize()
            self.position += direction_vector * move_distance
            
        if moving:
            current_time = pygame.time.get_ticks()
            if current_time - self.last_frame_time > self.frame_speed * 1000:
                self.frame += 1
                self.last_frame_time = current_time
            
            current_sprite = self.get_current_sprite()
        else:
            current_sprite = self.walk_down[0]  # Default idle sprite (down)
        self.rect.center = (self.position.x, self.position.y)  # <-- Sync sprite with position
        return self.position, current_sprite
    
    def switch_weapon(self, key):
        if key == pygame.K_TAB:
            current_index = self.weapons.index(self.current_weapon)
            next_index = (current_index + 1) % len(self.weapons)
            self.current_weapon = self.weapons[next_index]

    def attack(self, trees):
        if not self.attacking:
            return None

        if self.attack_frame_counter >= self.attack_frame_delay:
            self.attack_frame += 1
            self.attack_frame_counter = 0
        else:
            self.attack_frame_counter += 1

        sprite = self.get_attack_sprite()

        # Once we've shown the last frame, end the attack
        current_attack_frames = self.attack_frames[self.current_weapon]

        if self.direction == 'left':
            max_frames = len(current_attack_frames['left'])
        else:
            max_frames = len(current_attack_frames['right'])

        if self.attack_frame // 2 >= max_frames:
            self.attacking = False
            self.attack_frame = 0

        # Hit detection  
        attack_rect = self.get_attack_rect(50)

        if self.current_weapon == 'axe':
            for tree in trees:
                if attack_rect.colliderect(tree.get_hitbox()):
                    tree.start_animation()
        
        elif self.current_weapon == 'sword':
            # Here  can add "hit enemy" logic later
            pass
        
        elif self.current_weapon == 'hand':
            # Maybe do nothing
            pass
        
    def get_attack_sprite(self):
        idx = self.attack_frame // 2
        # Clamp it to the last valid frame
        max_idx = len(self.attack_frames[self.current_weapon]['right']) - 1
        idx = min(idx, max_idx)
        
        if self.direction == 'left':
            return self.attack_frames[self.current_weapon]['left'][idx]
        else:
            return self.attack_frames[self.current_weapon]['right'][idx]
    
    def get_attack_rect(self, range):
        if self.direction == 'up':
            return pygame.Rect(self.position.x - 20, self.position.y - range, 40, range)
        elif self.direction == 'down':
            return pygame.Rect(self.position.x - 20, self.position.y, 40, range)
        elif self.direction == 'left':
            return pygame.Rect(self.position.x - range, self.position.y - 20, range, 40)
        elif self.direction == 'right':
            return pygame.Rect(self.position.x, self.position.y - 20, range, 40)

    def get_current_sprite(self):
        sprite_list = {
            'up': self.walk_up,
            'down': self.walk_down,
            'left': self.walk_left,
            'right': self.walk_right
        }[self.direction]

        # Prevent index out of range
        self.frame %= len(sprite_list)
        return sprite_list[self.frame]
    def take_damage(self, amount):
        self.health -= amount
        if self.health < 0:
            self.health = 0
        print(f"Player health: {self.health}")

    def draw_health_bar(self, surface):
        bar_width = 200
        bar_height = 20
        fill = (self.health / 100) * bar_width
        x = (surface.get_width() - bar_width) // 2
        y = 570  # Bottom of screen
        pygame.draw.rect(surface, (255, 0, 0), (x, y, bar_width, bar_height))  # Red background
        pygame.draw.rect(surface, (0, 255, 0), (x, y, fill, bar_height))       # Green fill
        pygame.draw.rect(surface, (255, 255, 255), (x, y, bar_width, bar_height), 2)  # White border

class Tree:
    def __init__(self, position, frames):
        self.position = pygame.Vector2(position)
        self.frames = frames
        self.index = 0
        self.animating = False
        self.animation_speed = 0.2
        self.last_update_time = 0
        self.hold_duration = 10
        self.hold_start_time = 0
        self.is_holding = False

    def start_animation(self):
        if not self.animating and not self.is_holding:
            self.animating = True
            self.index = 0
            self.last_update_time = pygame.time.get_ticks() / 1000

    def update(self, current_time):
        if self.animating:
            if current_time - self.last_update_time > self.animation_speed:
                self.index += 1
                self.last_update_time = current_time
                if self.index >= 6:
                    self.index = 6
                    self.animating = False
                    self.is_holding = True
                    self.hold_start_time = current_time
        elif self.is_holding:
            if current_time - self.hold_start_time > self.hold_duration:
                self.is_holding = False
                self.index = 0

    def get_hitbox(self):
        hitbox_height = 20
        return pygame.Rect(
            self.position.x + 20,
            self.position.y + 100 - hitbox_height,
            100 - 40,
            hitbox_height
        )

    def draw(self, surface, camera):
        pos_on_surface = self.position - pygame.Vector2(camera.topleft)
        surface.blit(self.frames[self.index], pos_on_surface)

class Zombie(pygame.sprite.Sprite):
    def __init__(self, x, y, player):
        super().__init__()
        self.image = zombie_img.copy()
        self.idle_image = zombie_img.copy()
        self.image = self.idle_image
        self.rect = self.image.get_rect(center=(x, y))
        self.position = pygame.Vector2(x, y)  # Add Vector2 position tracking
        self.player = player
        self.speed = 1.5
        self.attack_range = 32
        self.attack_damage = 10
        self.last_attack_time = 0
        self.attack_cooldown = 1
        self.attack_windup_time = 0.3
        self.windup_start_time = None
        self.hp = 50
        self.max_hp = 50
        self.is_moving = False
        self.facing_left = False

        self.walk_images = zombie_walk_images
        self.attack_images = zombie_attack_images
        self.die_images = zombie_die_images

        self.animation_index = 0
        self.last_animation_time = time.time()
        self.animation_speed = 0.2

        self.is_wandering = True
        self.wander_direction = pygame.Vector2(random.uniform(-1, 1), random.uniform(-1, 1)).normalize()
        self.last_wander_time = time.time()
        self.wander_interval = 2
        self.pause_duration = 2

        self.state = "idle"
        self.is_dead = False
        self.death_time = 0
        self.death_duration = 1
        self.chase_range = 200

    def update_facing_direction(self):
        self.image = pygame.transform.flip(self.image, self.facing_left, False)

    def update(self):
        current_time = time.time()

        if self.is_dead:
            if current_time - self.last_animation_time > self.animation_speed:
                self.animation_index += 1
                if self.animation_index < len(self.die_images):
                    self.image = self.die_images[self.animation_index]
                    self.update_facing_direction()
                else:
                    self.image = self.die_images[-1]
                self.last_animation_time = current_time

            if current_time - self.death_time > self.death_duration:
                self.kill()
            return

        # Get player position (works with both Vector2 and rect)
        player_pos = getattr(self.player, 'position', pygame.Vector2(self.player.rect.center))
        
        # Calculate direction vector
        direction = player_pos - self.position
        distance = direction.length()
        
        # Update facing direction
        self.facing_left = direction.x < 0

        # Attack state handling
        if self.state == "attack":
            if self.windup_start_time:
                if current_time - self.windup_start_time >= self.attack_windup_time:
                    self.apply_attack_damage()
                    self.windup_start_time = None

            if current_time - self.last_animation_time > self.animation_speed:
                self.animation_index += 1
                if self.animation_index < len(self.attack_images):
                    self.image = self.attack_images[self.animation_index]
                    self.update_facing_direction()
                else:
                    self.state = "walk"
                    self.animation_index = 0
                self.last_animation_time = current_time
            return

        # Movement logic
        if distance < self.chase_range:
            if distance > self.attack_range:
                # Chase player
                if distance > 0:
                    direction = direction.normalize()
                self.position += direction * self.speed
                self.is_moving = True
            elif current_time - self.last_attack_time >= self.attack_cooldown:
                self.start_attack()
        else:
            # Wandering behavior
            if self.is_wandering:
                self.position += self.wander_direction * self.speed * 0.5
                self.is_moving = True

                if current_time - self.last_wander_time > self.wander_interval:
                    self.is_wandering = False
                    self.last_wander_time = current_time
            else:
                self.is_moving = False
                if current_time - self.last_wander_time > self.pause_duration:
                    self.is_wandering = True
                    self.last_wander_time = current_time
                    self.wander_direction = pygame.Vector2(random.uniform(-1, 1), random.uniform(-1, 1))
                    if self.wander_direction.length() > 0:
                        self.wander_direction = self.wander_direction.normalize()

        # Update rect position to match Vector2 position
        self.rect.center = (round(self.position.x), round(self.position.y))

        # Animation updates
        if self.is_moving:
            if current_time - self.last_animation_time > self.animation_speed:
                self.animation_index = (self.animation_index + 1) % len(self.walk_images)
                self.image = self.walk_images[self.animation_index]
                self.update_facing_direction()
                self.last_animation_time = current_time
        else:
            if self.state == "idle":
                self.image = self.idle_image
            elif self.state == "walk":
                if current_time - self.last_animation_time > self.animation_speed:
                    self.animation_index = (self.animation_index + 1) % len(self.walk_images)
                    self.image = self.walk_images[self.animation_index]
                    self.update_facing_direction()
                    self.last_animation_time = current_time()

    def start_attack(self):
        self.state = "attack"
        self.animation_index = 0
        self.windup_start_time = time.time()
        self.last_attack_time = time.time()
        print("Zombie starts wind-up...")

    def apply_attack_damage(self):
        # Recheck distance before applying damage
        player_pos = getattr(self.player, 'position', pygame.Vector2(self.player.rect.center))
        distance = (player_pos - self.position).length()

        if distance <= self.attack_range:
            print("Zombie attacks!")
            self.player.take_damage(self.attack_damage)
        else:
            print("Attack missed â€” player moved out of range.")

    def take_damage(self, amount, attacker_pos=None):
        self.hp -= amount
        print(f"Zombie HP: {self.hp}")

        if attacker_pos is not None:
            direction = self.position - pygame.Vector2(attacker_pos)
            if direction.length() > 0:
                direction = direction.normalize()
                knockback_distance = 20
                self.position += direction * knockback_distance
                self.rect.center = (round(self.position.x), round(self.position.y))

        if self.hp <= 0 and not self.is_dead:
            print("Zombie died!")
            self.state = "die"
            self.animation_index = 0
            self.is_dead = True
            self.death_time = time.time()

    def draw_health_bar(self, surface):
        bar_width = 30
        bar_height = 5
        fill = (self.hp / self.max_hp) * bar_width
        x = self.rect.centerx - bar_width // 2
        y = self.rect.top - 10
        pygame.draw.rect(surface, (255, 0, 0), (x, y, bar_width, bar_height))
        pygame.draw.rect(surface, (0, 255, 0), (x, y, fill, bar_height))

tree_sheet = pygame.image.load("rynn/tree-new.png").convert_alpha()
tree_frames = load_frames(tree_sheet, 100, 100, 0, 7)
trees = []
for _ in range(20):
    x = random.randint(0, min(1720, map_image.get_width()) - 100)
    y = random.randint(0, min(800, map_image.get_height()) - 100)
    trees.append(Tree((x, y), tree_frames))

player_instance = Player(player_position, speed)

# Sprite groups
all_sprites = pygame.sprite.Group()
zombie_group = pygame.sprite.Group()

spawn_delay = 3
last_spawn_time = time.time()

# Function to spawn zombies (limit to 10)
def spawn_zombie():
    if len(zombie_group) < 10:
        # Get a random spawn position from defined zones
        x, y = get_random_spawn_position_from_zones(zombie_spawn_zones)
        
        # Create the zombie at that position
        zombie = Zombie(x, y, player_instance)
        
        # Add the zombie to the groups
        zombie_group.add(zombie)
        all_sprites.add(zombie)
        print(f"Spawned zombie at ({x}, {y})")

def get_random_spawn_position_from_zones(zones):
    zone = random.choice(zones)  # Pick a random zone
    x = random.randint(zone.left, zone.right)
    y = random.randint(zone.top, zone.bottom)
    return (x, y)

zombie_spawn_zones = [
    pygame.Rect(121, 1221, 1235, 133),  # zone 1
]

running = True
while running:
    dt = clock.tick(60) / 1000
    current_time = pygame.time.get_ticks() / 1000

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_EQUALS:
                minimap_zoom_factor = min(4.0, minimap_zoom_factor + 0.1)
            elif event.key == pygame.K_MINUS:
                minimap_zoom_factor = max(0.5, minimap_zoom_factor - 0.1)
            elif event.key == pygame.K_TAB:
                player_instance.switch_weapon(event.key)

    keys = pygame.key.get_pressed()    
    new_position, current_sprite = player_instance.move(keys, dt)
    
    move_distance = speed * dt * 60

    current_time = time.time()
    if current_time - last_spawn_time >= spawn_delay and len(zombie_group) < 10:
        spawn_zombie()
        last_spawn_time = current_time
    
    zombie_group.update()

    # --- NEW Restriction check per direction ---
    proposed_position = player_instance.position.copy()

    if keys[pygame.K_w]:  # Up
        test_pos = proposed_position.copy()
        test_pos.y -= move_distance
        test_rect = pygame.Rect(test_pos.x - 20, test_pos.y - 20, 40, 40)
        if not is_in_restricted_zone(test_rect.center, restricted_zones):
            proposed_position.y -= move_distance
            player_instance.direction = 'up'
    if keys[pygame.K_s]:  # Down
        test_pos = proposed_position.copy()
        test_pos.y += move_distance
        test_rect = pygame.Rect(test_pos.x - 20, test_pos.y - 20, 40, 40)
        if not is_in_restricted_zone(test_rect.center, restricted_zones):
            proposed_position.y += move_distance
            player_instance.direction = 'down'
    if keys[pygame.K_a]:  # Left
        test_pos = proposed_position.copy()
        test_pos.x -= move_distance
        test_rect = pygame.Rect(test_pos.x - 20, test_pos.y - 20, 40, 40)
        if not is_in_restricted_zone(test_rect.center, restricted_zones):
            proposed_position.x -= move_distance
            player_instance.direction = 'left'
    if keys[pygame.K_d]:  # Right
        test_pos = proposed_position.copy()
        test_pos.x += move_distance
        test_rect = pygame.Rect(test_pos.x - 20, test_pos.y - 20, 40, 40)
        if not is_in_restricted_zone(test_rect.center, restricted_zones):
            proposed_position.x += move_distance
            player_instance.direction = 'right'

    proposed_position.x = max(0, min(proposed_position.x, map_image.get_width()))
    proposed_position.y = max(0, min(proposed_position.y, map_image.get_height()))

    player_instance.position = proposed_position
    player_position = proposed_position

    new_position, current_sprite = player_instance.move(keys, dt)
    attack_sprite = player_instance.attack(trees)

    if keys[pygame.K_SPACE] and not player_instance.attacking:
        player_instance.attacking = True

    new_position.x = max(0, min(new_position.x, map_image.get_width()))
    new_position.y = max(0, min(new_position.y, map_image.get_height()))
    # Update player_rect for collision checking
    player_rect = pygame.Rect(new_position.x - 2, new_position.y - 2, 4, 4)
    if not is_in_restricted_zone(player_rect.center, restricted_zones):
        player_position = new_position

    camera.center = player_position
    camera.clamp_ip(map_image.get_rect())

    zoom_surface.fill((0, 0, 0))
    zoom_surface.blit(map_image, (0, 0), camera)

    for tree in trees:
        tree.update(current_time)
        tree.draw(zoom_surface, camera)

    for zombie in zombie_group:
        zoom_surface.blit(zombie.image, zombie.rect.move(-camera.x, -camera.y))

    zoomed_view = pygame.transform.scale(zoom_surface, screen.get_size())
    screen.blit(zoomed_view, (0, 0))

    sprite_x = screen.get_width() // 2 - FRAME_WIDTH // 2
    sprite_y = screen.get_height() // 2 - FRAME_HEIGHT // 2

    if attack_sprite:
        screen.blit(attack_sprite, (sprite_x, sprite_y))
    else:
        screen.blit(current_sprite, (sprite_x, sprite_y))

    minimap_surface = pygame.Surface((minimap_radius * 2, minimap_radius * 2), pygame.SRCALPHA)
    mini_camera_size = minimap_radius * 2 / minimap_zoom_factor
    mini_camera = pygame.Rect(0, 0, mini_camera_size, mini_camera_size)
    mini_camera.center = player_position
    mini_camera.clamp_ip(map_image.get_rect())
    mini_view = map_image.subsurface(mini_camera).copy()
    scaled_mini_view = pygame.transform.scale(mini_view, (minimap_radius * 2, minimap_radius * 2))
    minimap_surface.blit(scaled_mini_view, (0, 0))
    masked_minimap = minimap_surface.copy()
    masked_minimap.blit(minimap_mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
    pygame.draw.circle(masked_minimap, player_minimap_color, (minimap_radius, minimap_radius), 3)
    pygame.draw.circle(masked_minimap, minimap_border_color, (minimap_radius, minimap_radius), minimap_radius, minimap_border_width)
    screen.blit(masked_minimap, (minimap_pos[0] - minimap_radius, minimap_pos[1] - minimap_radius))

    time_counter += dt
    alpha = int((math.sin(time_counter * cycle_speed) + 1) / 2 * 150)
    overlay.fill((0, 0, 0, alpha))
    screen.blit(overlay, (0, 0))

    pos_text = f"X: {int(player_position.x)}  Y: {int(player_position.y)}"
    text_surface = font.render(pos_text, True, (255, 255, 255))
    screen.blit(text_surface, (10, screen.get_height() - 30))
 
    pygame.display.flip()

pygame.quit()
sys.exit()
