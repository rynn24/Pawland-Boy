import pygame
import os
import math
import sys
import random

# Initialise
pygame.init()
screen = pygame.display.set_mode((620, 480))
pygame.display.set_caption("Pawland Boy")
clock = pygame.time.Clock()

font = pygame.font.SysFont(None, 24)

# Load map 
map_image = pygame.image.load(os.path.join("rynn/Map.png")).convert()

camera_width, camera_height = 320, 180
camera = pygame.Rect(0, 0, camera_width, camera_height)
zoom_surface = pygame.Surface((camera_width, camera_height))
player_position = pygame.Vector2(320, 180)
speed = 2
restricted_zones = [] # Not yet set up

# Day-night cycle
overlay = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
time_counter = 0
cycle_speed = (2 * math.pi) / 30

# Minimap settings
minimap_radius = 80
minimap_zoom_factor = 0.5
minimap_pos = (minimap_radius + 10, minimap_radius + 10)
minimap_border_color = (0, 0, 0)
minimap_border_width = 2
player_minimap_color = (255, 50, 50)
minimap_mask = pygame.Surface((minimap_radius * 2, minimap_radius * 2), pygame.SRCALPHA)
pygame.draw.circle(minimap_mask, (255, 255, 255), (minimap_radius, minimap_radius), minimap_radius)


FRAME_WIDTH, FRAME_HEIGHT = 200, 200

def load_frames(sheet, frame_width, frame_height, row, num_frames):
    return [sheet.subsurface(pygame.Rect(i * frame_width, row * frame_height, frame_width, frame_height)) for i in range(num_frames)]

class Player:
    def __init__(self, position, speed):
        self.position = position
        self.speed = speed
        self.direction = 'down'
        self.attacking = False
        self.frame = 0
        self.attack_frame = 0
        self.last_frame_time = 0
        self.frame_speed = 0.1
        self.attack_frame_delay = 3  # Delay between attack frames
        self.attack_frame_counter = 0

        # Load player sprite sheets
        self.walk_sheet = pygame.image.load("minting/character.png").convert_alpha()
        self.attack_sheet = pygame.image.load("minting/attack.png").convert_alpha()

        self.walk_down = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 0, 3)
        self.walk_up = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 1, 4)
        self.walk_left = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 2, 4)
        self.walk_right = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 3, 4)

        self.attack_right = load_frames(self.attack_sheet, FRAME_WIDTH, FRAME_HEIGHT, 0, 4)
        self.attack_left = load_frames(self.attack_sheet, FRAME_WIDTH, FRAME_HEIGHT, 1, 4)

    def move(self, keys, dt):
        move_distance = self.speed * dt * 60
        moving = False
        new_position = self.position.copy()

        if self.attacking:
            return new_position, self.get_attack_sprite()  # Prevent movement while attacking

        if keys[pygame.K_w]:
            self.position.y -= move_distance
            self.direction = 'up'
            moving = True
        if keys[pygame.K_s]:
            self.position.y += move_distance
            self.direction = 'down'
            moving = True
        if keys[pygame.K_a]:
            self.position.x -= move_distance
            self.direction = 'left'
            moving = True
        if keys[pygame.K_d]:
            self.position.x += move_distance
            self.direction = 'right'
            moving = True
        
        if moving:
            current_time = pygame.time.get_ticks()
            if current_time - self.last_frame_time > self.frame_speed * 1000:
                self.frame += 1
                self.last_frame_time = current_time

            current_sprite = self.get_current_sprite()
        else:
            current_sprite = self.walk_down[0]  # Default idle sprite (down)

        return self.position, current_sprite
    
    def attack(self, trees):
        if not self.attacking:
            return None

        # Advance the attack_frame at your chosen delay
        if self.attack_frame_counter >= self.attack_frame_delay:
            self.attack_frame += 1
            self.attack_frame_counter = 0
        else:
            self.attack_frame_counter += 1

        sprite = self.get_attack_sprite()

        # Once we've shown the last frame, end the attack
        if self.attack_frame // 2 >= len(self.attack_right):
            self.attacking = False
            self.attack_frame = 0

        # Hit detection (unchanged)
        attack_rect = self.get_attack_rect(50)
        for tree in trees:
            if attack_rect.colliderect(tree.get_hitbox()):
                tree.start_animation()

        return sprite
        
    def get_attack_sprite(self):
        # Calculate raw index
        idx = self.attack_frame // 2
        # Clamp it to the last valid frame
        max_idx = len(self.attack_right) - 1
        idx = min(idx, max_idx)
        if self.direction == 'left':
            return self.attack_left[idx]
        else:
            return self.attack_right[idx]
    
    def get_attack_rect(self, range):
        if self.direction == 'up':
            return pygame.Rect(self.position.x - 20, self.position.y - range, 40, range)
        elif self.direction == 'down':
            return pygame.Rect(self.position.x - 20, self.position.y, 40, range)
        elif self.direction == 'left':
            return pygame.Rect(self.position.x - range, self.position.y - 20, range, 40)
        elif self.direction == 'right':
            return pygame.Rect(self.position.x, self.position.y - 20, range, 40)
        
    def get_current_sprite(self):
        if self.direction == 'down':
            return self.walk_down[self.frame % len(self.walk_down)]
        elif self.direction == 'up':
            return self.walk_up[self.frame % len(self.walk_up)]
        elif self.direction == 'left':
            return self.walk_left[self.frame % len(self.walk_left)]
        elif self.direction == 'right':
            return self.walk_right[self.frame % len(self.walk_right)]
# Character setup
speed = 1
player_instance = Player(pygame.Vector2(320, 180), speed)

# Tree animation
tree_sheet = pygame.image.load("rynn/tree-sprite.png").convert_alpha()
TREE_FRAME_WIDTH, TREE_FRAME_HEIGHT = 100, 100
tree_frames = load_frames(tree_sheet, TREE_FRAME_WIDTH, TREE_FRAME_HEIGHT, 0, 6)
HOLD_FRAME_INDEX = 6  

class Tree:
    def __init__(self, position, frames):
        self.position = pygame.Vector2(position)
        self.frames = frames
        self.index = 0
        self.animating = False
        self.animation_speed = 0.2  
        self.last_update_time = 0
        self.hold_duration = 10  # Hold the last frame before tree respawn
        self.hold_start_time = 0
        self.is_holding = False

    def start_animation(self):
        if not self.animating and not self.is_holding:
            self.animating = True
            self.index = 0
            self.last_update_time = pygame.time.get_ticks() / 1000
            self.is_holding = False

    def update(self, current_time):
        if self.animating:
            if current_time - self.last_update_time > self.animation_speed:
                self.index += 1
                self.last_update_time = current_time
                if self.index >= HOLD_FRAME_INDEX:
                    self.index = HOLD_FRAME_INDEX
                    self.animating = False
                    self.is_holding = True
                    self.hold_start_time = current_time
        
        elif self.is_holding:
            if current_time - self.hold_start_time > self.hold_duration:
                self.is_holding = False
                self.index = 0  # Reset to first frame

    def get_hitbox(self):
        hitbox_height = 20
        return pygame.Rect(
            self.position.x + 20,  
            self.position.y + TREE_FRAME_HEIGHT - hitbox_height,
            TREE_FRAME_WIDTH - 40,
            hitbox_height
        )

    def draw(self, surface, camera):
        if self.index >= len(self.frames):
            self.index = len(self.frames) - 1  

        pos_on_surface = self.position - pygame.Vector2(camera.topleft)

        surface.blit(self.frames[self.index], pos_on_surface)

# Generate trees
trees = []
for _ in range(10):
    x = random.randint(0, min(1920, map_image.get_width()) - TREE_FRAME_WIDTH)
    y = random.randint(0, min(1440, map_image.get_height()) - TREE_FRAME_HEIGHT)
    trees.append(Tree((x, y), tree_frames))

running = True
while running:
    dt = clock.tick(60) / 1000
    current_time = pygame.time.get_ticks() / 1000

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_EQUALS:
                minimap_zoom_factor = min(4.0, minimap_zoom_factor + 0.1)
            elif event.key == pygame.K_MINUS:
                minimap_zoom_factor = max(0.5, minimap_zoom_factor - 0.1)

    new_position = player_position.copy()
    keys = pygame.key.get_pressed()
    move_distance = speed * dt * 60
    moving = False 
    current_sprite = player_instance.move(keys, dt)
    attack_sprite = player_instance.attack(trees)
    new_position, current_sprite = player_instance.move(keys, dt)

    if keys[pygame.K_SPACE] and not player_instance.attacking:
        player_instance.attacking = True

    new_position.x = max(0, min(new_position.x, map_image.get_width()))
    new_position.y = max(0, min(new_position.y, map_image.get_height()))
    # Update player_rect for collision checking
    player_rect = pygame.Rect(new_position.x - 2, new_position.y - 2, 4, 4)
    if not any(zone.colliderect(player_rect) for zone in restricted_zones):
        player_position = new_position

    camera.center = player_position
    camera.clamp_ip(map_image.get_rect())

    zoom_surface.fill((0, 0, 0))
    zoom_surface.blit(map_image, (0, 0), camera)

    for tree in trees:
        tree.update(current_time)
        tree.draw(zoom_surface, camera)

    zoomed_view = pygame.transform.scale(zoom_surface, screen.get_size())
    screen.blit(zoomed_view, (0, 0))

    sprite_x = screen.get_width() // 2 - FRAME_WIDTH // 2
    sprite_y = screen.get_height() // 2 - FRAME_HEIGHT // 2

    if attack_sprite:
        screen.blit(attack_sprite, (sprite_x, sprite_y))
    else:
        screen.blit(current_sprite, (sprite_x, sprite_y))

    # Minimap and other UI elements
    minimap_surface = pygame.Surface((minimap_radius * 2, minimap_radius * 2), pygame.SRCALPHA)
    mini_camera_size = minimap_radius * 2 / minimap_zoom_factor
    mini_camera = pygame.Rect(0, 0, mini_camera_size, mini_camera_size)
    mini_camera.center = player_position
    mini_camera.clamp_ip(map_image.get_rect())
    mini_view = map_image.subsurface(mini_camera).copy()
    scaled_mini_view = pygame.transform.scale(mini_view, (minimap_radius * 2, minimap_radius * 2))
    minimap_surface.blit(scaled_mini_view, (0, 0))
    masked_minimap = minimap_surface.copy()
    masked_minimap.blit(minimap_mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
    pygame.draw.circle(masked_minimap, player_minimap_color, (minimap_radius, minimap_radius), 3)
    pygame.draw.circle(masked_minimap, minimap_border_color, (minimap_radius, minimap_radius), minimap_radius, minimap_border_width)
    screen.blit(masked_minimap, (minimap_pos[0] - minimap_radius, minimap_pos[1] - minimap_radius))

    time_counter += dt
    alpha = int((math.sin(time_counter * cycle_speed) + 1) / 2 * 150)
    overlay.fill((0, 0, 0, alpha))
    screen.blit(overlay, (0, 0))

    pos_text = f"X: {int(player_position.x)}  Y: {int(player_position.y)}"
    text_surface = font.render(pos_text, True, (255, 255, 255))
    screen.blit(text_surface, (10, screen.get_height() - 30))

    pygame.display.flip()

pygame.quit()
sys.exit()
