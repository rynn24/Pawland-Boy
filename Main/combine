import pygame
import os
import sys
import random
import time
import json

# Initialize
pygame.init()
window_size = (620, 480)
is_fullscreen = False
screen = pygame.display.set_mode(window_size)
overlay = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
pygame.display.set_caption("Pawland Boy")
clock = pygame.time.Clock()

# Scaling variables
character_scale = 1.0  # Normal size
fullscreen_scale = 2.0  # Scale factor when in fullscreen

# fonts
font = pygame.font.SysFont(None, 24)
reward_font = pygame.font.Font(None, 45) # font for fishing reward

# Load map image
map_image = pygame.image.load(os.path.join("images/Map2.png")).convert()

# Camera and player position 
camera_width, camera_height = 320, 180
camera = pygame.Rect(0, 0, camera_width, camera_height)
zoom_surface = pygame.Surface((camera_width, camera_height))
player_position = pygame.Vector2(1500, 125)
speed = 2

# Player restricted area
restricted_zones = [
    # Pond area
    {
        "type": "ellipse",
        "center": (1554, 585),
        "radius_x": 165,
        "radius_y": 162
    },
        {
        "type": "rect",
        "rect": pygame.Rect(753, 0, 440, 275)  # x, y, width, height
    }   
] 

# Trees restricted area
tree_restricted_zones = [
    # Pond area (ellipse)
    {
        "type": "ellipse",
        "center": (1554, 585),
        "radius_x": 170,
        "radius_y": 170
    },
    # Top area (rectangle)
    {
        "type": "rect",
        "rect": pygame.Rect(0, 0, 1900, 340)
    },
    # Boss area (rectangle)
    {
        "type": "rect", 
        "rect": pygame.Rect(240, 144, 342, 129)
    },
    # Right area(rectangle)
    {
        "type": "rect",
        "rect": pygame.Rect(1750, 0, 170, 1440)
    },
    # Bottom area(rectangle)
    {
        "type": "rect",
        "rect": pygame.Rect(0, 1340, 1920, 100)
    },
    # Left area(rectangle)
    {
        "type": "rect",
        "rect": pygame.Rect(0, 284, 164, 1060)
    }
]

# House area & load images
house_area = [

        {
        "type": "rect",
        "rect": pygame.Rect(1464, 144, 116, 56)
    }   
] 
in_house = False
cooking_ui_visible = False
house_image = pygame.image.load("images/house/inside-house.png").convert()
house_rect = house_image.get_rect()
show_house_prompt = False
paper_image = pygame.image.load("images/house/paper.jpg").convert()
paper_visible = False
crafting_visible = False
recipe_visible = False
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (100, 100, 100)
LIGHT_GRAY = (200, 200, 200)
DARK_BLUE = (30, 30, 50)
RED = (255, 50, 50)

# ENDING
show_escape_ui = False
escape_ui_triggered = False
playing_boat_animation = False
show_the_end_screen = False
boat_built = False  
boss_defeated = False 

boat_riding_frames = []  # Will store your sprite sheet frames
current_boat_frame = 0
boat_anim_timer = 0
boat_frame_duration = 200  # milliseconds per frame
boat_riding_sheet = pygame.image.load("images/map-sprite/firefly.png").convert_alpha()
frame_width = 100
frame_height = 100
num_frames = 7  # Adjust based on your sprite sheet

for i in range(num_frames):
    frame = boat_riding_sheet.subsurface((i * frame_width, 0, frame_width, frame_height))
    boat_riding_frames.append(frame)

def trim_surface(surface):
    """Remove transparent padding around the surface."""
    mask = pygame.mask.from_surface(surface)
    rect = mask.get_bounding_rects()[0] if mask.get_bounding_rects() else surface.get_rect()
    trimmed_surface = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)
    trimmed_surface.blit(surface, (0, 0), rect)
    return trimmed_surface   

button_image = pygame.image.load("haojun/image/login.png").convert_alpha()
button_image2 = pygame.image.load("haojun/image/register.png").convert_alpha()
button_imagetrim = trim_surface(button_image)
button_image2trim = trim_surface(button_image2)

def scale_sprite(sprite, scale):
    if scale == 1.0:
        return sprite  # No scaling needed
    original_size = sprite.get_size()
    new_size = (int(original_size[0] * scale), int(original_size[1] * scale))
    return pygame.transform.scale(sprite, new_size)

def is_in_ellipse(point, center, radius_x, radius_y):
    px, py = point
    cx, cy = center
    dx = (px - cx) ** 2 / (radius_x ** 2)
    dy = (py - cy) ** 2 / (radius_y ** 2)
    result = dx + dy <= 1
    return result

def is_in_restricted_zone(point, zones):
    for zone in zones:
        if zone["type"] == "ellipse":
            if is_in_ellipse(point, zone["center"], zone["radius_x"], zone["radius_y"]):
                return True
        elif zone["type"] == "rect":
            rect = pygame.Rect(*zone["rect"])
            if rect.collidepoint(point):
                return True
    return False

# For trees restricted zone
def is_valid_tree_position(pos, restricted_zones):
    for zone in restricted_zones:
        if zone["type"] == "ellipse":
            if is_in_ellipse(pos, zone["center"], zone["radius_x"], zone["radius_y"]):
                return False  # Tree cannot grow here
        elif zone["type"] == "rect":
            if zone["rect"].collidepoint(pos):
                return False  # Tree cannot grow here
    return True  

# Day-night cycle
cycle_duration = 60  # 60 seconds total for one full cycle
day_duration = cycle_duration * 0.66  # 66% day → 39.6 seconds
night_duration = cycle_duration * 0.34  # 34% night → 20.4 seconds
time_counter = 0



# Minimap settings
minimap_radius = 60
minimap_zoom_factor = 0.2
minimap_pos = (minimap_radius + 10, minimap_radius + 10)
minimap_border_color = BLACK
minimap_border_width = 2
player_minimap_color = (255, 50, 50)
minimap_mask = pygame.Surface((minimap_radius * 2, minimap_radius * 2), pygame.SRCALPHA)
pygame.draw.circle(minimap_mask, (255, 255, 255), (minimap_radius, minimap_radius), minimap_radius)

FRAME_WIDTH, FRAME_HEIGHT = 200, 200

def load_frames(sheet, frame_width, frame_height, row, num_frames, spacing=0):
    return [sheet.subsurface(pygame.Rect(i * frame_width, row * frame_height, frame_width, frame_height)) for i in range(num_frames)]

def load_frames_from_sheet(sheet_path, frame_width, frame_height, rows, columns, resize_to=None):
    sheet = pygame.image.load(sheet_path).convert_alpha()
    frames = []

    for row in range(rows):
        row_frames = []
        for col in range(columns):
            x = col * frame_width
            y = row * frame_height
            frame = sheet.subsurface(pygame.Rect(x, y, frame_width, frame_height))
            if resize_to:
                frame = pygame.transform.scale(frame, resize_to)  # resize only if needed
            row_frames.append(frame)
        frames.append(row_frames)
    
    return frames  # e.g., frames[0] = walk, frames[1] = attack

zombie_img = pygame.image.load("haojun/image/zombie.png").convert_alpha()  # <--- STEP 1
zombie_img = pygame.transform.scale(zombie_img, (46, 46))
zombie_attack_images = load_frames_from_sheet("haojun/image/zombie attack.png", 46, 46,1, 4)[0]
zombie_die_images = load_frames_from_sheet("haojun/image/zombie get attack.png", 46, 46,1, 4)[0]
zombie_walk_images =load_frames_from_sheet("haojun/image/zombie walk.png", 46, 46, 1, 5)[0]
boss_attack_frames = load_frames_from_sheet("haojun/image/boss attack.png", 76, 76, 1, 5)[0]
boss_walk_frames = load_frames_from_sheet("haojun/image/boss walk.png", 76, 76, 1, 3)[0]
boss_die_frames = load_frames_from_sheet("haojun/image/boss die.png", 76, 76, 1, 4)[0]
boss_ult_frames = load_frames_from_sheet("haojun/image/boss ult.png", 76, 76, 1, 6)[0]


class Inventory:
    def __init__(self, max_slots=16):
        print("⚠️ NEW Inventory created!", id(self))
        self.items = {}
        self.max_slots = max_slots
        self.slots = [None] * self.max_slots  # Initial empty slots
        self.slot_rects = []
        self.font = pygame.font.SysFont("Arial", 20)
        self.item_icons = {
            "Wood": {"image": pygame.image.load("minting/Wood.png").convert_alpha(), "categories": ["material"]},
            "Fruit": {"image": pygame.image.load("minting/Fruit.png").convert_alpha(), "categories": ["ingredient", "food"]},
            "Fish": {"image": pygame.image.load("images/pond/fish_1.png").convert_alpha(), "categories": ["ingredient"]},
            "Big Fish": {"image": pygame.image.load("images/pond/fish_2.png").convert_alpha(), "categories": ["ingredient"]},
            "Crystal": {"image": pygame.image.load("images/pond/crystal.png").convert_alpha(), "categories": ["material"]},
            "Boat": {"image": pygame.image.load("minting/Boat.png").convert_alpha(), "categories": ["tool"]},
            "Firefly": {"image": pygame.image.load("minting/Firefly.jpg").convert_alpha(), "categories": ["material"]},
            "Armor(Iron)":{"image":pygame.image.load("haojun/image/armor(iron).png").convert_alpha(), "categories": ["tool"]},
            "Armor(Gold)":{"image":pygame.image.load("haojun/image/armor(gold).png").convert_alpha(), "categories": ["tool"]},
            "Armor(Diamond)":{"image":pygame.image.load("haojun/image/armor(diamond).png").convert_alpha(), "categories": ["tool"]},
            "FishBone_Clip": {"image":pygame.image.load("minting/FishBoneClip.png").convert_alpha(),"categories": ["skin"]},
            "ZombiePaw":{"image":pygame.image.load("minting/zombie_head.png").convert_alpha(),"categories": ["skin"]},
        }

        self.recipes = {
        "Fish Soup": {"ingredients": [("Fish", 1), ("Fruit", 1)], "result": ("Fish Soup", 1)},
        "Grilled Fish": {"ingredients": [("Fish", 1),("Fish", 1)], "result": ("Grilled Fish", 1)},
        "Sweet Sailor": {"ingredients": [("Big Fish", 1), ("Fruit", 1)], "result": ("Sweet Sailor", 1)},
        "Fruit Jam": {"ingredients": [("Fruit", 1), ("Fruit", 1)], "result": ("Fruit Jam", 1)},
        "Reef Medley": {"ingredients": [("Big Fish", 1), ("Big Fish", 1)], "result": ("Reef Medley", 1)},
        "Twinfin Delight": {"ingredients": [("Big Fish", 1), ("Fish", 1)], "result": ("Twinfin Delight", 1)},
    }

        # Add images for the new food items
        self.item_icons["Fish Soup"] = {"image": pygame.image.load("images/food/fish-soup.png").convert_alpha(), "categories": "food"}
        self.item_icons["Grilled Fish"] = {"image": pygame.image.load("images/food/grill-fish.png").convert_alpha(), "categories": "food"}
        self.item_icons["Sweet Sailor"] = {"image": pygame.image.load("images/food/sweet-sailor.png").convert_alpha(), "categories": "food"}
        self.item_icons["Fruit Jam"] = {"image": pygame.image.load("images/food/jam.png").convert_alpha(), "categories": "food"}
        self.item_icons["Reef Medley"] = {"image": pygame.image.load("images/food/reef.png").convert_alpha(), "categories": "food"}
        self.item_icons["Twinfin Delight"] = {"image": pygame.image.load("images/food/twin.png").convert_alpha(), "categories": "food"}
        
            
        self.slot_size = 60
        self.slot_margin = 10
        self.is_inventory_open = False  # Track whether inventory is open
        self.columns = 4  # Define number of columns
        self.rows = 4     # Define number of rows (max_slots / columns)

        # Increase the size of the inventory window for better spacing
        self.window_width = self.columns * (self.slot_size + self.slot_margin) + self.slot_margin 
        self.window_height =self.rows * (self.slot_size + self.slot_margin) + self.slot_margin  # 4 rows of slots + margin
        self.window_rect = pygame.Rect(50, 100, self.window_width, self.window_height)  # Position and size of the window (stick to the left)
        self.window_color = (139, 69, 19)  # Brown color for the window (wood-like)

        # Define positions of the 5 visible slots (always on the screen)
        self.visible_slots_rects = []
        self.visible_slots_x = (800 - self.columns * (self.slot_size + self.slot_margin)) // 2  # Centered on top
        self.visible_slots_y = 50  # Start y position for visible slots
        self.generate_slot_rects()

    def generate_slot_rects(self):
        """Generate the positions for all the inventory slots"""
        self.slot_rects = []
        # Window slots (4 columns)
        start_x = self.window_rect.x + self.slot_margin
        start_y = self.window_rect.y + self.slot_margin

        # Calculate the positions for each of the 20 slots (5 columns x 4 rows)
        for i in range(self.max_slots):
            col = i % self.columns
            row = i // self.columns
            x = start_x + col * (self.slot_size + self.slot_margin)
            y = start_y + row * (self.slot_size + self.slot_margin)
            self.slot_rects.append(pygame.Rect(x, y, self.slot_size, self.slot_size))

        # Define the visible slots (always on the screen)
        self.visible_slots_rects = []
        for i in range(self.columns):  # Now 4 slots
            x = self.visible_slots_x + i * (self.slot_size + self.slot_margin)
            y = self.visible_slots_y
            self.visible_slots_rects.append(pygame.Rect(x, y, self.slot_size, self.slot_size))
    
    def get_slot_at_pos(self, pos):
        if not self.window_rect.collidepoint(pos):
            return None
            
        rel_x = pos[0] - self.window_rect.left - self.slot_margin
        rel_y = pos[1] - self.window_rect.top - self.slot_margin

        if rel_x < 0 or rel_y < 0:
            return None 
        
        col = rel_x // (self.slot_size + self.slot_margin)
        row = rel_y // (self.slot_size + self.slot_margin)
        
        # Enforce 4-column limit
        if col >= self.columns or row >= self.rows:  
            return None
            
        slot_index = row * self.columns + col
        return slot_index if slot_index < self.max_slots else None
    
    def toggle_inventory(self):
        """Toggle the inventory screen (open/close)"""
        self.is_inventory_open = not self.is_inventory_open

    def draw(self, surface):
        """Draw the inventory window and slots"""
        # Draw the visible 5 slots (always on screen)
        for i, rect in enumerate(self.visible_slots_rects):
            pygame.draw.rect(surface, (200, 200, 200), rect)

            item = self.slots[i]
            if item:
                name, count = item
                self.draw_item_icon(surface, name, count, rect)  # 🎯 Draw icon + count


        # Draw the inventory window when it is open
        if self.is_inventory_open:
            # Draw the window background (wooden texture/solid color)
            pygame.draw.rect(surface, self.window_color, self.window_rect)

            # Draw the slots inside the window
            for rect in self.slot_rects:
                pygame.draw.rect(surface, (200, 200, 200), rect)  # Draw slot box (gray)
                item = self.slots[self.slot_rects.index(rect)]
                if item:
                    name, count = item
                    self.draw_item_icon(surface, name, count, rect)

    def add_item(self, name, count):
        # 1. Try to find and combine with existing item of same name
        for i in range(self.max_slots):
            item = self.slots[i]
            if item is not None and item[0] == name:
                current_name, current_count = item
                self.slots[i] = (current_name, current_count + count)
                return True

        # 2. If not found, find an empty slot to insert
        for i in range(self.max_slots):
            if self.slots[i] is None:
                self.slots[i] = (name, count)
                return True

        # 3. Inventory full
        return False

    def draw_item_icon(self, surface, name, count, rect):
        if name in self.item_icons:
            icon_data = self.item_icons[name]
            
            # Set default icon
            if isinstance(icon_data, pygame.Surface):
                icon = icon_data
                show_count = True  # Default to True if no categories
            elif isinstance(icon_data, dict) and "image" in icon_data:
                icon = icon_data["image"]
                # Only show count if not armor
                categories = icon_data.get("categories", [])
                show_count = not any(c in categories for c in ["tool", "skin"])
            else:
                return  # Skip if icon is invalid

            # Resize and draw icon
            icon = pygame.transform.smoothscale(icon, (self.slot_size - 10, self.slot_size - 10))
            icon_rect = icon.get_rect(center=rect.center)
            surface.blit(icon, icon_rect)

            # Draw item count (if not armor)
            if show_count:
                count_text = self.font.render(f"x{count}", True, (0, 0, 0))
                count_rect = count_text.get_rect(bottomright=(rect.right - 4, rect.bottom - 2))
                surface.blit(count_text, count_rect)
            
    def get_inventory_dict(self):
        """Return inventory as a dictionary for saving purposes."""
        data = {}
        for slot in self.slots:
            if slot:
                item_name, item_count = slot
                data[item_name] = item_count  # Store just the name and count
        return data

    
    def set_items(self, items_dict):
        """Load saved items into the inventory"""
        self.slots = [None] * self.max_slots
        index = 0
        for name, count in items_dict.items():
            if index < self.max_slots:
                self.slots[index] = (name, count)
                index += 1

    def remove_item(self, index, amount=1):
        if self.slots[index]:
            name, count = self.slots[index]
            count -= amount
            if count <= 0:
                self.slots[index] = None
            else:
                self.slots[index] = (name, count)
                
    def get_inventory_dict(self):
        """Return inventory as a dictionary for saving purposes."""
        data = {}
        for slot in self.slots:
            if slot:
                item_name, item_count = slot
                data[item_name] = item_count  # Store just the name and count
        return data

    
    def set_items(self, items_dict):
        """Load saved items into the inventory"""
        self.slots = [None] * self.max_slots
        index = 0
        for name, count in items_dict.items():
            if index < self.max_slots:
                self.slots[index] = (name, count)
                index += 1
                
    def has_item(self, item_name):
        for slot in self.slots:
            if slot is not None:
                if isinstance(slot, (tuple, list)) and len(slot) > 0:
                    if slot[0] == item_name:
                        return True
        return False
    
    def get_item_count(self, item_name):
        total = 0
        for slot in self.slots:
            if slot and slot[0] == item_name:
                total += slot[1]
        return total
    
    def remove_items(self, item_name, amount):
        """Remove 'amount' of 'item_name' from inventory slots, starting from first slots."""
        remaining = amount
        for i, slot in enumerate(self.slots):
            if slot and slot[0] == item_name:
                name, count = slot
                if count > remaining:
                    self.slots[i] = (name, count - remaining)
                    return True  # done removing
                else:
                    self.slots[i] = None  # remove whole slot
                    remaining -= count
                if remaining <= 0:
                    return True
        # Not enough items to remove
        return False    
    
class UserSystem:
    def __init__(self, filename="profile.json"):
        self.filename = filename
        self.users = self.load_users()
        self.current_user = None

    def save_users(self):
            
            with open(self.filename, "w") as f:
                json.dump(self.users, f, indent=2)  # Pretty-print for debugging
            print("✅ Users saved successfully.")
            return True


    def inspect_for_unserializables(self, data, path="root"):
        if isinstance(data, dict):
            for key, value in data.items():
                self.inspect_for_unserializables(value, f"{path}['{key}']")
        elif isinstance(data, list):
            for index, item in enumerate(data):
                self.inspect_for_unserializables(item, f"{path}[{index}]")
        else:
            try:
                json.dumps(data)
            except TypeError:
                print(f"❗ Unserializable data at {path}: {type(data)} -> {repr(data)}")


    def load_users(self):
        if not os.path.exists(self.filename):
            return {}
        with open(self.filename, "r") as f:
            return json.load(f)
        
    def register(self, username):
        if username in self.users:
            return False  # Username taken
        # Store initial player data
        self.users[username] = {
            "health": 100,  # Initial health
            "position": [1500,125],  # Initial position (center of screen)
            "inventory": { 
            },
            "level": 1,
            "exp": 0,
            "achievements": {},
            "boat_progress": 0,
            "boat_crystals": 0,
            "boat_built": False,
            "boss_defeated": False,
 
        }
        self.save_users()
        return True

    def login(self, username):
        if username in self.users :
            self.current_user = username
            return True
        return False

    def logout(self):
        self.current_user = None

    def get_player_data(self, username):
        if username not in self.users:
            print(f"Error: User '{username}' not found in users database!")  # More descriptive error
            return 100, pygame.Vector2(1500, 125), {}  # Default values, but now you know the user is missing
        
        user_data = self.users.get(username, {})
        health = user_data.get("health", 100)
        position = user_data.get("position", [1500, 125])
        inventory = user_data.get("inventory", {})
        level = user_data.get("level", 1)
        exp = user_data.get("exp", 0)
        boat_progress = user_data.get("boat_progress", 0)
        boat_crystals = user_data.get("boat_crystals", 0)
        boat_built = user_data.get("boat_built", False)
        boss_defeated = user_data.get("boss_defeated", False)
 
        
        
        print(f"get_player_data inventory for {username}: {inventory}")
    
        if isinstance(position, dict):
            position = [position.get("0", 1500), position.get("1", 125)]

        return health, position, inventory, level, exp, boat_progress, boat_crystals, boat_built, boss_defeated

    def get_inventory_dict(self, username):
        inventory = self.users[username]["inventory"]
        inventory_dict = {}

        # Ensure we are iterating correctly based on the inventory structure
        for item_name, item_data in inventory.items():
            if isinstance(item_data, tuple) or isinstance(item_data, list):
                # Handle if the item data is a tuple or list (e.g., item count might be the first element)
                item_count = item_data[0]  # assuming the first element is the count
                inventory_dict[item_name] = item_count
            else:
                # If it's just a simple count value
                inventory_dict[item_name] = item_data

        return inventory_dict

    def save_progress(self, username, health, position, inventory_dict, level, exp, achievements=None, shown_achievements=None, stats=None, day=None, boat_built=False, boss_defeated=False):
        print(f"[DEBUG] save_progress called for username: {username}")
        if username in self.users:
            # Convert position to list if it's a Vector2
            if isinstance(position, pygame.Vector2):
                position = [position.x, position.y]
            elif hasattr(position, '__iter__'):  # If it's already a list/tuple
                position = [float(position[0]), float(position[1])]
            
            self.users[username] = {
                "health": health,
                "position": position,
                "inventory": inventory_dict,
                "level": level,
                "exp": exp,
                "boat_progress": boat_progress,
                "boat_crystals": boat_crystals,
                 "boat_built" : boat_built,
                 "boss_defeated" : boss_defeated
            }
            if achievements is not None:
                self.users[username]["achievements"] = achievements
            if shown_achievements is not None:
                self.users[username]["shown_achievements"] = list(shown_achievements)  # Save set as list
            if stats is not None:
                self.users[username]["stats"] = stats  # ⬅ Save player progress stats
            print(f"Saving data for {username}: {self.users[username]}")  # Debug print
            self.save_users()

        else:
            print(f"Username {username} not found in users!")  # Add this debug line!

class MainMenu:
    def __init__(self, screen, window_size, button_imagetrim=None, button_image2trim=None):
        self.screen = screen
        self.window_size = window_size
        self.font = pygame.font.SysFont(None, 48)
        self.frame_spritesheet = pygame.image.load("haojun/image/background image.png").convert_alpha()
        self.login_button = Button(window_size[0] // 2 - 100, 200, 200, 50, "Choose Profile",
                                   (50, 150, 50), (100, 200, 100), (255, 255, 255),
                                   image=button_imagetrim)
        self.register_button = Button(window_size[0] // 2 - 100, 270, 200, 50, "Create Profile",
                                      (50, 50, 150), (100, 100, 200), (255, 255, 255),
                                      image=button_image2trim)
        # Assuming sprite sheet is horizontal strip of frames, e.g. 5 frames
        self.frame_width = self.frame_spritesheet.get_width() // 12
        self.frame_height = self.frame_spritesheet.get_height()
        self.frames = []
        for i in range(12):
            frame = self.frame_spritesheet.subsurface(
                (i * self.frame_width, 0, self.frame_width, self.frame_height))
            frame = pygame.transform.scale(frame, self.window_size)  # scale frame to window size
            self.frames.append(frame)

        self.current_frame = 0
        self.frame_timer = 0
        self.frame_delay = 175  # milliseconds between frames

    def handle_events(self, events):
        for event in events:
            if self.login_button.is_clicked(pygame.mouse.get_pos(), event):
                return "login_page"
            if self.register_button.is_clicked(pygame.mouse.get_pos(), event):
                return "register_page"
        return None
    
    def update(self, dt):
        # Update animation timer
        self.frame_timer += dt
        if self.frame_timer >= self.frame_delay:
            self.frame_timer = 0
            self.current_frame = (self.current_frame + 1) % len(self.frames)

    def draw(self):
        # Draw current animated frame as background
        self.screen.blit(self.frames[self.current_frame], (0, 0))
        title = self.font.render("Pawland Boy", True, (255, 255, 255))
        self.screen.blit(title, (self.window_size[0] // 2 - title.get_width() // 2, 100))
        self.login_button.draw(self.screen)
        self.register_button.draw(self.screen)
        pygame.display.flip()

def loading_screen(screen, font):
    clock = pygame.time.Clock()
    loading = True

    # Draw "Loading..." text
    while loading:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        screen.fill((30, 30, 30))
        text = font.render("Loading...", True, (255, 255, 255))
        screen.blit(text, (screen.get_width() // 2 - text.get_width() // 2,
                           screen.get_height() // 2 - text.get_height() // 2))
        pygame.display.flip()
        spritesheets = {
            "movement": pygame.image.load("minting/TWALK.png").convert_alpha(),
            "attack": pygame.image.load("minting/TATTACK.png").convert_alpha(),
            "inventory": pygame.image.load("minting/TINVENTORY.png").convert_alpha(),
            "fishing": pygame.image.load("minting/TFISH.png").convert_alpha(),
            "enemy": pygame.image.load("minting/TENEMY.png").convert_alpha(),
            "weapon": pygame.image.load("minting/TWEAPON.png").convert_alpha(),
            "cook": pygame.image.load("minting/TCOOK.png").convert_alpha(),
            "exp": pygame.image.load("minting/TEXP.png").convert_alpha(),
        }

        loading = False  # Exit loop after loading once
        clock.tick(60)

    return spritesheets

class TutorialPage:
    def __init__(self, title, text, spritesheet_surface, frame_width, frame_height):
        self.title = title
        self.text = text
        self.frames = []
        self.frame_index = 0
        self.frame_timer = 0
        self.frame_delay = 0.10

        if spritesheet_surface:  # Check if path is not None/empty
            self.frames = self._extract_frames(spritesheet_surface, frame_width, frame_height)

    def _extract_frames(self, spritesheet_surface, frame_width, frame_height):
        frames = []
        try:
            sheet_width, sheet_height = spritesheet_surface.get_size()
            
            for y in range(0, sheet_height, frame_height):
                for x in range(0, sheet_width, frame_width):
                    frame = spritesheet_surface.subsurface(pygame.Rect(x, y, frame_width, frame_height))
                    frames.append(frame)
        except Exception as e:
            print(f"Error loading spritesheet: {e}")
        return frames


    def update(self, dt):
        self.frame_timer += dt
        if self.frame_timer >= self.frame_delay:
            self.frame_timer = 0
            if not self.frames:
                return
            self.frame_index = (self.frame_index + 1) % len(self.frames)


    def draw(self, surface, font, x, y, w, h):
        # Draw background
        pygame.draw.rect(surface, (245, 245, 220), (x, y, w, h))
        pygame.draw.rect(surface, (200, 200, 200), (x, y, w, h), 2)

        # Draw title
        title_surf = font.render(self.title, True, (0, 0, 0))
        surface.blit(title_surf, (x + 20, y + 20))

        # Word wrap the text within (w - 40) width
        wrapped_lines = self.wrap_text(self.text, font, w - 40)
        
        # Draw wrapped text lines below title
        line_height = font.get_height()
        text_y = y + 20 + title_surf.get_height() + 10  # space after title
        for line in wrapped_lines:
            text_surf = font.render(line, True, (0, 0, 0,))
            surface.blit(text_surf, (x + 20, text_y))
            text_y += line_height

        # Draw animation frame below text
        if not self.frames:
            return
        frame = self.frames[self.frame_index]

        # Calculate max width and height for frame
        max_frame_width = w - 40
        max_frame_height = h - (text_y - y) - 20  # remaining space below text minus padding

        # Scale frame proportionally to fit max size
        frame_w, frame_h = frame.get_size()
        scale = min(max_frame_width / frame_w, max_frame_height / frame_h)
        new_size = (int(frame_w * scale), int(frame_h * scale))
        frame_scaled = pygame.transform.scale(frame, (new_size))

        # Center the frame horizontally, position below text
        frame_x = x + (w - new_size[0]) // 2
        frame_y = text_y + 10

        surface.blit(frame_scaled, (frame_x, frame_y))


    def wrap_text(self, text, font, max_width):
        """Split text into lines that fit max_width."""
        words = text.split(' ')
        lines = []
        current_line = ''

        for word in words:
            test_line = current_line + word + ' '
            if font.size(test_line)[0] <= max_width:
                current_line = test_line
            else:
                lines.append(current_line.rstrip())
                current_line = word + ' '
        if current_line:
            lines.append(current_line.rstrip())
        return lines
    
    def get_total_height(self, w, font):
        title_height = font.get_height()
        text_lines = self.wrap_text(self.text, font, w - 40)
        text_height = len(text_lines) * font.get_height()
        frame_height = 150  # Estimate or calculate actual image size
        return 20 + title_height + 10 + text_height + 10 + frame_height + 20

# Load spritesheets first
spritesheets = loading_screen(screen, font)

tutorial_pages = [
    TutorialPage("Tutorial", "tap the red colour book or use T key for open and close this tutorial.",[], 310, 240),
    TutorialPage("Goal", "Build boat in at least 50 days , kill boss and escape Pawland!",[], 310, 240),
    TutorialPage("Movement", "Use W A S D to move.", spritesheets["movement"], 1440, 1080),
    TutorialPage("Attack & Chop", "Press SPACE to attack and chop.", spritesheets["attack"], 1440, 1080),
    TutorialPage("Inventory", "Press B to open and close inventory.Try out different button for different item.",spritesheets["inventory"], 772, 590),
    TutorialPage("Fishing", "Approach the pond and press J,random item will be given!!",spritesheets["fishing"],1440, 1080),
    TutorialPage("Respawn", "You will respawn after getting killed. Beware the boss!", spritesheets["enemy"], 1440, 1080),
    TutorialPage("Weapon", "Use Tab to change weapon", spritesheets["weapon"], 1440, 1080),
    TutorialPage("Cooking", "Tap and pull the ingredient to cook .Try different ingredients!", spritesheets["cook"], 1440, 1080),
    TutorialPage("Level & exp", "Gain exp from trees and enemies. HP restores when leveling up!",spritesheets["exp"],1440, 1080),
 ]


class TutorialManager:
    def __init__(self, font, tutorial_pages, window_size, pos=(100, 100), size=(400, 300)):
        self.font = font
        self.pages = tutorial_pages
        self.pos = pos
        self.size = size
        self.show = False
        self.page_index = 0
        self.sidebar_width = 150
        self.button_height = 50
        self.window_size = window_size
        self.scroll_offset = 0  # initialize before clamping
        self.scroll_speed = 20
        self.sidebar_scroll_offset = 0
        self.sidebar_max_scroll = 0 

        self.help_icon = pygame.image.load("minting/tutorialbook.png").convert_alpha()
        self.help_icon = pygame.transform.scale(self.help_icon, (60, 60))
        self.help_icon_rect = self.help_icon.get_rect(topleft=(160, 50))

        # Temporarily assign content_h to calculate max scroll
        content_h = self.size[1]
        content_w = self.size[0] - self.sidebar_width - 20
        self.max_scroll = max(0, self.pages[self.page_index].get_total_height(content_w, self.font) - content_h)


        

    def toggle(self):
        self.show = not self.show
        print(f"Tutorial show = {self.show}")
        self.pages[self.page_index].frame_index = 0
        self.pages[self.page_index].frame_timer = 0

    def next_page(self):
        self.page_index = (self.page_index + 1) % len(self.pages)

    def prev_page(self):
        self.page_index = (self.page_index - 1) % len(self.pages)

    def update(self, dt):
        if self.show:   
            self.pages[self.page_index].update(dt)

    def draw(self, surface):
        if not self.show:
            screen.blit(self.help_icon, self.help_icon_rect)
            return
        if self.show:
            x, y = self.pos
            w, h = self.size

           # Darken background like settings menu
            overlay = pygame.Surface(self.window_size, pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 180))
            screen.blit(overlay, (0, 0))

            # Compute sidebar max scroll
            total_sidebar_height = len(self.pages) * self.button_height
            self.sidebar_max_scroll = max(0, total_sidebar_height - self.size[1])
            self.sidebar_scroll_offset = max(0, min(self.sidebar_scroll_offset, self.sidebar_max_scroll))

            # Draw sidebar background
            pygame.draw.rect(surface, (238, 232, 170), (x, y, self.sidebar_width, h))

            # Sidebar scroll area
            sidebar_clip = pygame.Rect(x, y, self.sidebar_width, h)
            surface.set_clip(sidebar_clip)

            for i, page in enumerate(self.pages):
                btn_y = y + i * self.button_height - self.sidebar_scroll_offset
                btn_rect = pygame.Rect(x, btn_y, self.sidebar_width, self.button_height)

                # Skip drawing if button is outside the sidebar area
                if btn_rect.bottom < y or btn_rect.top > y + h:
                    continue

                color = (240, 218, 129) if i == self.page_index else (243, 252, 192)
                pygame.draw.rect(surface, color, btn_rect)
                text_surf = self.font.render(page.title, True, (0, 0, 0))
                surface.blit(text_surf, (btn_rect.x + 10, btn_rect.y + 10))

            surface.set_clip(None)  # Reset clipping
            # Draw selected tutorial page
            content_x = x + self.sidebar_width + 10
            content_y = y
            content_w = w - self.sidebar_width - 20
            content_h = h
            self.pages[self.page_index].draw(
                surface, self.font, content_x, content_y, content_w, content_h
            )


    def handle_event(self, event):
        if not self.show:
            return

        # Always update max_scroll before handling scroll input
        content_w = self.size[0] - self.sidebar_width - 20
        content_h = self.size[1]
        self.max_scroll = max(0, self.pages[self.page_index].get_total_height(content_w, self.font) - content_h)

        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1:
                mx, my = event.pos
                x, y = self.pos
                for i in range(len(self.pages)):
                    btn_y = y + i * self.button_height - self.sidebar_scroll_offset  # FIXED
                    btn_rect = pygame.Rect(x, btn_y, self.sidebar_width, self.button_height)
                    if btn_rect.collidepoint(mx, my):
                        self.page_index = i
                        self.pages[i].frame_index = 0  # Reset animation
                        self.pages[i].frame_timer = 0
                        self.scroll_offset = 0  # reset scroll when switching page
                        break
            elif event.button in (4, 5):  # Scroll wheel
                mx, my = pygame.mouse.get_pos()
                sidebar_rect = pygame.Rect(self.pos[0], self.pos[1], self.sidebar_width, self.size[1])
                        
                if sidebar_rect.collidepoint(mx, my):
                    # Scrolling sidebar
                    if event.button == 4:
                        self.sidebar_scroll_offset = max(0, self.sidebar_scroll_offset - self.scroll_speed)
                    elif event.button == 5:
                        self.sidebar_scroll_offset = min(self.sidebar_scroll_offset + self.scroll_speed, self.sidebar_max_scroll)

    def clamp_scroll(self):
        self.scroll_offset = max(0, min(self.scroll_offset, self.max_scroll))

    def update_layout(self, window_size):
        self.window_size = window_size
        width, height = window_size

        box_width = int(width * 0.7)
        box_height = int(height * 0.7)
        box_x = (width - box_width) // 2
        box_y = (height - box_height) // 2

        self.pos = (box_x, box_y)
        self.size = (box_width, box_height)



tutorial = TutorialManager(font, tutorial_pages, screen.get_size())

class LoginPage:
    def __init__(self, screen, user_system, window_size,button_imagetrim = None):
        self.screen = screen
        self.user_system = user_system
        self.window_size = window_size
        self.font = pygame.font.SysFont(None, 36)
        self.back_button = Button(20, 20, 100, 40, "Back",
                                  (100, 100, 100), (150, 150, 150), (255, 255, 255))
        self.username_rects = []  # Store clickable rects
        self.frame_spritesheet = pygame.image.load("haojun/image/background image.png").convert_alpha()
        self.frame_width = self.frame_spritesheet.get_width() // 12
        self.frame_height = self.frame_spritesheet.get_height()
        self.frames = [
            pygame.transform.scale(
                self.frame_spritesheet.subsurface((i * self.frame_width, 0, self.frame_width, self.frame_height)),
                self.window_size
            ) for i in range(12)
        ]
        self.current_frame = 0
        self.frame_timer = 0
        self.frame_delay = 200  # milliseconds between frames
        self.user_button_image = button_imagetrim
    
    def update(self, dt):
        self.frame_timer += dt
        if self.frame_timer >= self.frame_delay:
            self.frame_timer = 0
            self.current_frame = (self.current_frame + 1) % len(self.frames)

    def handle_events(self, events):
        for event in events:
            if self.back_button.is_clicked(pygame.mouse.get_pos(), event):
                return "main_menu"

            if event.type == pygame.MOUSEBUTTONDOWN:
                pos = event.pos
                for rect, username in self.username_rects:
                    if rect.collidepoint(pos):
                        self.user_system.current_user = username
                        return "game", username

        return None

    def draw(self):
        self.screen.blit(self.frames[self.current_frame], (0, 0))
        self.username_rects.clear()

        title = self.font.render("Select Profile", True, (255, 255, 255))
        self.screen.blit(title, (self.window_size[0] // 2 - title.get_width() // 2, 60))

        # Grid layout config
        usernames = list(self.user_system.users.keys())
        cols = 3
        button_width = 160
        button_height = 40
        col_spacing = 200
        row_spacing = 60
        start_x = 40
        start_y = 140

        mouse_pos = pygame.mouse.get_pos()

        for i, username in enumerate(usernames):
            col = i % cols
            row = i // cols
            x = start_x + col * col_spacing
            y = start_y + row * row_spacing

            # Button rect
            rect = pygame.Rect(x, y, button_width, button_height)
            color = (100, 100, 100)

            # Hover effect
            if rect.collidepoint(mouse_pos):
                color = (150, 150, 150)

            # Draw button background
            button_scaled = pygame.transform.scale(self.user_button_image, (160, 40))
            self.screen.blit(button_scaled, (x, y))
            # Render username centered in the button
            label = self.font.render(username, True, (255, 255, 255))
            label_x = rect.centerx - label.get_width() // 2
            label_y = rect.centery - label.get_height() // 2
            self.screen.blit(label, (label_x, label_y))

            self.username_rects.append((rect, username))

        self.back_button.draw(self.screen)
        pygame.display.flip()

class RegisterPage:
    def __init__(self, screen, user_system, window_size,tutorial,button_image2trim=None):
        self.tutorial = tutorial
        self.screen = screen
        self.user_system = user_system
        self.window_size = window_size
        self.font = pygame.font.SysFont(None, 36)
        self.username_input = ""
        self.input_rect = pygame.Rect(window_size[0] // 2 - 100, 160, 220, 40)
        self.active_input = False
        self.register_button = Button(window_size[0] // 2 - 60, 220, 120, 40, "Create Profile",
                                      (50, 100, 150), (100, 150, 200), (255, 255, 255),image=button_image2trim)
        self.back_button = Button(20, 20, 100, 40, "Back",
                                  (100, 100, 100), (150, 150, 150), (255, 255, 255))
        self.message = ""
        self.frame_spritesheet = pygame.image.load("haojun/image/background image.png").convert_alpha()
        self.frame_width = self.frame_spritesheet.get_width() // 12
        self.frame_height = self.frame_spritesheet.get_height()
        self.frames = [
            pygame.transform.scale(
                self.frame_spritesheet.subsurface((i * self.frame_width, 0, self.frame_width, self.frame_height)),
                self.window_size
            ) for i in range(12)
        ]
        self.current_frame = 0
        self.frame_timer = 0
        self.frame_delay = 200  # milliseconds between frames

    def update(self, dt):
        self.frame_timer += dt
        if self.frame_timer >= self.frame_delay:
            self.frame_timer = 0
            self.current_frame = (self.current_frame + 1) % len(self.frames)

    def handle_events(self, events):
        for event in events:
            if self.back_button.is_clicked(pygame.mouse.get_pos(), event):
                return "main_menu"

            if event.type == pygame.MOUSEBUTTONDOWN:
                if self.input_rect.collidepoint(event.pos):
                    self.active_input = True
                else:
                    self.active_input = False

                if self.register_button.is_clicked(event.pos, event):
                    if self.username_input:
                        if self.user_system.register(self.username_input):
                            tutorial.show = True
                            return "game", self.username_input
                        else:
                            self.message = "Username already exists!"

            elif event.type == pygame.KEYDOWN and self.active_input:
                if event.key == pygame.K_RETURN:
                    pass
                elif event.key == pygame.K_BACKSPACE:
                    self.username_input = self.username_input[:-1]
                else:
                    if len(self.username_input) < 20:
                        self.username_input += event.unicode
        return None

    def draw(self):
        self.screen.blit(self.frames[self.current_frame], (0, 0))
        title = self.font.render("Create New Profile", True, (255, 255, 255))
        self.screen.blit(title, (self.window_size[0] // 2 - title.get_width() // 2, 80))

        pygame.draw.rect(self.screen, (255, 255, 255) if self.active_input else (180, 180, 180),
                         self.input_rect, 2)
        input_text = self.font.render(self.username_input, True, (255, 255, 255))
        self.screen.blit(input_text, (self.input_rect.x + 8, self.input_rect.y + 6))

        if not self.username_input and not self.active_input:
            placeholder = self.font.render("Enter username...", True, (100, 100, 100))
            self.screen.blit(placeholder, (self.input_rect.x + 8, self.input_rect.y + 6))

        self.register_button.draw(self.screen)
        self.back_button.draw(self.screen)

        if self.message:
            msg = self.font.render(self.message, True, (255, 0, 0))
            self.screen.blit(msg, (self.window_size[0] // 2 - msg.get_width() // 2, 280))

        pygame.display.flip()

class InventoryMenu:
    def __init__(self, inventory, window_size, player):
        self.player_instance = player
        self.visible = False
        self.inventory = inventory  # Reference to your Inventory instance
        self.window_size = window_size
        self.font = pygame.font.SysFont("Arial", 24)
        
        # Define window rect for the bag display area
        self.window_rect = pygame.Rect(
            window_size[0]//2 - 250, window_size[1]//2 - 200,
            500, 400
        )
        self.bg_color = (50, 50, 70)
        self.selected_index = None
        self.button_font = pygame.font.SysFont("Arial", 20)

        self.item_buttons = {
            "Fruit": [
                {"label": "Eat", "action": "eat"},
                {"label": "Drop", "action": "drop"},
            ],
            "Wood": [
                {"label": "Drop", "action": "drop"},
            ],
            "Fish": [
                {"label": "Drop", "action": "drop"},
            ],
            "Fish Soup": [
                {"label": "Eat", "action": "eat"},
                {"label": "Drop", "action": "drop"},
            ],
            "Grilled Fish": [
                {"label": "Eat", "action": "eat"},
                {"label": "Drop", "action": "drop"},
            ],
            "Sweet Sailor": [
                {"label": "Eat", "action": "eat"},
                {"label": "Drop", "action": "drop"},
            ],
            "Fruit Jam": [
                {"label": "Eat", "action": "eat"},
                {"label": "Drop", "action": "drop"},
            ],
            "Reef Medly": [
                {"label": "Eat", "action": "eat"},
                {"label": "Drop", "action": "drop"},
            ],
            "Twinfin Delight": [
                {"label": "Eat", "action": "eat"},
                {"label": "Drop", "action": "drop"},
            ],
            # Default fallback if item is not listed
            "default": [
                {"label": "Drop", "action": "drop"},
            ],
            "FishBone_Clip": [
                {"label": "Equip", "action": "equip"},
                {"label": "Unequip", "action": "unequip"},
            ],
            "ZombiePaw": [
                {"label": "Equip", "action": "equip"},
                {"label": "Unequip", "action": "unequip"},
            ],
        }
        self.item_descriptions = {
            "Wood": "Can be used to build things.",
            "Fruit": "Restores a small amount of health.",
            "Fish": "A basic fish.",
            "Big Fish": "A bigger and longer fish , maybe can unlock some dishes ?",
            "Crystal": "Shiny rock.",
            "Boat": "Used for traveling across water.",
            "Firefly": "Cute bugs that glows in the dark.",
            "FishBone_Clip":"A stylish clip. Might smell fishy.",
            "Fish Soup": "A delicious soup made from fish and fruit. Restores 30 health.",
            "Grilled Fish": "Perfectly cooked fish. Restores 20 health.",
            "Armor(Iron)": "Sturdy protection for everyday survival. Reduces incoming damage by 10%.(This item cannot be drop or use)",
            "Armor(Gold)": "Shiny but practical. Lightweight defense that cuts damage by 30%.(This item cannot be drop or use)",
            "Armor(Diamond)": "Top-tier protection forged from rare diamonds. Reduces damage by 50%.(This item cannot be drop or use)",
            "Sweet Sailor": "A gourmet meal. Restores 50 health",
            "Fruit Jam": "Sweet fruit jam. Increases movement speed for 20 seconds. ",   
            "Reef Medley": "A vibrant fusion of ocean flavours.",
            "Twinfin Delight": "A harmonious dish crafted from 2 types of fish. " ,
            "ZombiePaw" : "A costume get after killing a lot zombies ."         
        }
        
    def toggle(self):
        self.visible = not self.visible
        
    def draw(self, screen):
        if not self.visible:
            return
        
        # Darken background like settings menu
        overlay = pygame.Surface(self.window_size, pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        screen.blit(overlay, (0, 0))
        
        # Draw the bag window background
        pygame.draw.rect(screen, self.bg_color, self.window_rect, border_radius=10)
        pygame.draw.rect(screen, (255, 255, 255), self.window_rect, 2, border_radius=10)
        
        # Title
        title = self.font.render("Inventory", True, (255, 255, 255))
        screen.blit(title, (self.window_rect.centerx - title.get_width() // 2, self.window_rect.top + 20))
        
        # Draw all the inventory slots inside the window_rect area
        # We'll draw them in a grid, e.g. 5 columns x 4 rows, similar to your Inventory
        start_x = self.window_rect.left + 30  
        start_y = self.window_rect.top + 70
        slot_size = 60
        slot_margin = 10
        slots_per_row = 4   

        
        for i in range(self.inventory.max_slots):
            x = start_x + (i % slots_per_row) * (slot_size + slot_margin)
            y = start_y + (i // slots_per_row) * (slot_size + slot_margin)
            slot_rect = pygame.Rect(x, y, slot_size, slot_size)
            
            # Draw slot box
            pygame.draw.rect(screen, (150, 150, 150), slot_rect)
            
            # Draw item icon + count if present
            item = self.inventory.slots[i]
            if item:
                name, count = item
                self.inventory.draw_item_icon(screen, name, count, slot_rect)
        
        # Right panel area (inside window_rect)
        info_x = self.window_rect.right - 180
        info_y = self.window_rect.top + 70
        pygame.draw.rect(screen, (70, 70, 90), (info_x, info_y, 150, 250), border_radius=8)
        pygame.draw.rect(screen, (200, 200, 200), (info_x, info_y, 150, 250), 2, border_radius=8)

        # Show description
        if self.selected_index is not None:
            item = self.inventory.slots[self.selected_index]
            if item:
                name, count = item
                # Show item name
                name_text = self.font.render(name, True, (255, 255, 255))
                screen.blit(name_text, (info_x + 10, info_y + 10))

                # Show item description below name
                description = self.item_descriptions.get(name, "No description.")
                desc_font = pygame.font.SysFont("Arial", 18)
                wrapped_lines = self.wrap_text(description, desc_font, 130)
                for j, line in enumerate(wrapped_lines):
                    line_surf = desc_font.render(line, True, (200, 200, 200))
                    screen.blit(line_surf, (info_x + 10, info_y + 40 + j * 20))


                # Get the selected item and its buttons
                buttons = self.item_buttons.get(name, self.item_buttons["default"])

                if "Armor" in name:
                    buttons = []

                # Calculate where to start placing buttons
                button_start_y = info_y + 40 + len(wrapped_lines) * 20 + 10

                for i, btn in enumerate(buttons):
                    btn_rect = pygame.Rect(info_x + 10, button_start_y + i * 45, 130, 35)

                    pygame.draw.rect(screen, (100, 100, 130), btn_rect, border_radius=5)
                    label = self.button_font.render(btn["label"], True, (255, 255, 255))
                    screen.blit(label, (btn_rect.centerx - label.get_width() // 2, btn_rect.centery - label.get_height() // 2))
                    btn["rect"] = btn_rect  # Store the rect for click detection

                # Update buttons list for click detection
                self.buttons = buttons
            else: 
                self.buttons = []

    def wrap_text(self, text, font, max_width):
        """Split long description text into multiple lines if needed."""
        words = text.split(" ")
        lines = []
        current_line = ""

        for word in words:
            test_line = current_line + word + " "
            if font.size(test_line)[0] <= max_width:
                current_line = test_line
            else:
                lines.append(current_line.strip())
                current_line = word + " "
        if current_line:
            lines.append(current_line.strip())

        return lines

    def handle_click(self, pos):
        print(f"Click at {pos}, selected_index before: {self.selected_index}")
        # Check item slots
        start_x = self.window_rect.left + 30
        start_y = self.window_rect.top + 70
        slot_size = 60
        slot_margin = 10
        slots_per_row = 4   

        for i in range(self.inventory.max_slots):
            x = start_x + (i % slots_per_row) * (slot_size + slot_margin)
            y = start_y + (i // slots_per_row) * (slot_size + slot_margin)
            slot_rect = pygame.Rect(x, y, slot_size, slot_size)
            if slot_rect.collidepoint(pos):
                self.selected_index = i
                return


        # Check button clicks (if any selected)
        if self.selected_index is not None:
            for btn in self.buttons:
                if "rect" in btn and btn["rect"].collidepoint(pos):
                    action = btn["action"]
                    self.perform_action(action, self.selected_index)
    
    def perform_action(self, action, index):
        item = self.inventory.slots[index]
        if not item:
            print("No item in slot!")
            return

        name, count = item
        
        if name == "Fruit" and action == "eat":
            print(f"Eating {name}")
            self.player_instance.gain_health(5)
            self.inventory.remove_item(index, 1)

        elif action == "eat" and self.inventory.item_icons[name]["categories"] == "food":
            if name == "Fish Soup":
                self.player_instance.gain_health(30)
            elif name == "Grilled Fish":
                self.player_instance.gain_health(20)
            elif name == "Special Dish":
                self.player_instance.gain_health(50)
            elif name == "Reef Medly":
                self.player_instance.gain_health(30)
                self.player_instance.gain_speed(1.5, duration = 30)
            elif name == "Twinfin Delight":
                self.player_instance.gain_health(100)
                # Could add temporary buffs here
            self.inventory.remove_item(index, 1)

        elif action == "drop":
            print(f"Dropping {name}")
            self.inventory.remove_item(index, 1)

        elif action == "equip":
            print(f"Equipping {name}")
            if name == "FishBone_Clip":
                self.player_instance.equip_hairclip(name)
            if name == "ZombiePaw":
                self.player_instance.equip_zombieskin(name)
                
        elif action == "unequip":
            print(f"Unequipping {name}")
            if name == "FishBone_Clip":
                self.player_instance.unequip_hairclip ()
            if name == "ZombiePaw":
                self.player_instance.unequip_zombieskin()
 
        else:
            print(f"No action implemented for: {action}")
            
    def update_layout(self, window_size):
        self.window_size = window_size
        self.window_rect = pygame.Rect(
            self.window_size[0] // 2 - 250,
            self.window_size[1] // 2 - 200,
            500, 400
        )

class SettingsMenu:
    def __init__(self, screen_size):
        self.visible = False
        self.buttons = []
        self.font = pygame.font.SysFont(None, 36)
        self.small_font = pygame.font.SysFont(None, 24)
        self.screen_size = screen_size  # Save the initial screen size

        # Initialize music
        pygame.mixer.init()
        try:
            self.music = pygame.mixer.Sound("haojun/music 1.mp3")  # Replace with your music file
            self.music_volume = 0.5
            self.music.play(-1)
            self.music.set_volume(self.music_volume)
        except:
            self.music = None
            print("Could not load music file")

        # Create buttons using the current screen size
        self.create_buttons(self.screen_size)
    
    def create_buttons(self, screen_size):
        self.buttons.clear()
        w, h = screen_size
        
        button_width = 200
        button_height = 40
        spacing = 20  # space between buttons
        
        buttons_text = [
            ("View Achievements", (50, 200, 50), (100, 250, 100)),
            ("Back to Game", (50, 50, 200), (100, 100, 250)),
            ("Quit Game", (200, 50, 50), (250, 100, 100))
        ]
        
        # Reserve vertical space for title + volume + controls text
        text_block_height = 36 + 36 + 24 + 20  # font sizes + some padding
        
        total_height = len(buttons_text) * button_height + (len(buttons_text) - 1) * spacing
        start_y = (h // 2 - total_height // 2) + text_block_height // 2 - 20  # Push buttons below texts
        
        for i, (text, color_normal, color_hover) in enumerate(buttons_text):
            x = w // 2 - button_width // 2
            y = start_y + i * (button_height + spacing)
            btn = Button(x, y, button_width, button_height, text, color_normal, color_hover, (255, 255, 255))
            self.buttons.append(btn)

    def draw(self, screen):
        w, h = screen.get_size()

        overlay = pygame.Surface((w, h), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        screen.blit(overlay, (0, 0))
        
        # Calculate the full menu height dynamically
        buttons_height = len(self.buttons) * 40 + (len(self.buttons) - 1) * 20
        text_block_height = 36 + 36 + 24 + 20  # title + volume + controls + padding
        menu_height = buttons_height + text_block_height + 60  # extra padding
        
        menu_rect = pygame.Rect(w // 2 - 200, h // 2 - menu_height // 2, 400, menu_height)
        pygame.draw.rect(screen, (100, 100, 100), menu_rect, border_radius=10)
        pygame.draw.rect(screen, (255, 255, 255), menu_rect, 2, border_radius=10)

        # Draw texts
        y_text = menu_rect.top + 20
        
        title = self.font.render("Settings", True, (255, 255, 255))
        screen.blit(title, (w // 2 - title.get_width() // 2, y_text))
        
        y_text += title.get_height() + 10

        vol_text = self.font.render(f"Music Volume: {int(self.music_volume * 100)}%", True, (255, 255, 255))
        screen.blit(vol_text, (w // 2 - vol_text.get_width() // 2, y_text))

        y_text += vol_text.get_height() + 5

        controls_text = self.small_font.render("Use LEFT/RIGHT arrows to adjust", True, (200, 200, 200))
        screen.blit(controls_text, (w // 2 - controls_text.get_width() // 2, y_text))

        # Draw buttons
        for button in self.buttons:
            button.draw(screen)
    
    def handle_events(self, event):
        mouse_pos = pygame.mouse.get_pos()
        
        for button in self.buttons:
            button.check_hover(mouse_pos)
            if button.is_clicked(mouse_pos, event):
                if button.text == "Quit Game":
                    return "quit"
                elif button.text == "Back to Game":
                    self.visible = False
                    return "back"
                elif button.text == "View Achievements":
                    return "achievements"  # 🔁 NEW: Trigger achievements screen

        # Handle volume keys
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_LEFT:
                self.adjust_volume(-0.1)
            elif event.key == pygame.K_RIGHT:
                self.adjust_volume(0.1)
    
    def adjust_volume(self, change):
        self.music_volume = max(0.0, min(1.0, self.music_volume + change))
        if self.music:
            self.music.set_volume(self.music_volume)
    

class Button:
    def __init__(self, x, y, width, height, text, color, hover_color, text_color, font_size=24, image = None):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.color = color
        self.hover_color = hover_color
        self.text_color = text_color
        self.font = pygame.font.SysFont(None, font_size)
        self.is_hovered = False
        if image:
            self.image = pygame.transform.scale(image, (width, height))
        else:
            self.image = None
        
    def draw(self, surface):
        if self.image:
            surface.blit(self.image, self.rect)
        else:
            color = self.hover_color if self.is_hovered else self.color
            pygame.draw.rect(surface, color, self.rect, border_radius=5)
            pygame.draw.rect(surface, (0, 0, 0), self.rect, 2, border_radius=5)

        # Draw the text over the image or background
        text_surf = self.font.render(self.text, True, self.text_color)
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)
        
    def check_hover(self, pos):
        self.is_hovered = self.rect.collidepoint(pos)
        return self.is_hovered
        
    def is_clicked(self, pos, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            return self.rect.collidepoint(pos)
        return False
    
class Player:
    def __init__(self, position, speed, username, level, exp, achievement_system=None, ):
        self.username = username
        self.user_system = UserSystem()
        self.health, self.position, self.inventory, self.level, self.exp, self.boat_progress, self.boat_crystals, self.boat_built, self.boss_defeated = self.user_system.get_player_data(self.username)
        print(f"Loaded player data for {self.username}: health={self.health}, position={self.position}, inventory={self.inventory},level={self.level}, exp={self.exp}")

        self.position = pygame.Vector2(self.position[0], self.position[1])
        self.speed = 2
        if isinstance(self.position, list) or isinstance(self.position, tuple):
            self.position = pygame.Vector2(self.position[0], self.position[1])

        self.image = pygame.image.load("minting/character.png").convert_alpha()
        self.rect = self.image.get_rect(center=(self.position.x, self.position.y))
        self.direction = 'down'
        self.attacking = False
        self.frame = 0
        self.attack_frame = 0
        self.last_frame_time = 0
        self.frame_speed = 0.2
        self.attack_frame_delay = 3
        self.attack_frame_counter = 0
        self.weapons = ['hand', 'axe', 'sword']
        self.current_weapon = 'hand'
        self.last_update = pygame.time.get_ticks()
        self.animation_cooldown = 100
        self.level = level

        self.exp = exp
        self.exp_to_next_level = self.calculate_exp_needed(self.level)
        self.max_health= 100*self.level
        self.achievement_system = achievement_system
        self.original_speed = self.speed
        self.speed_timer = 0 
        self.attack_sound_played = False
        
        self.armor_type = None 
        self.current_attack_targets = []
        self.attack_multipliers = [0, 1, 1.5, 1.8, 2.0, 2.5, 3.0, 4.0, 6.0]  # Index = level
        self.weapon_icons = {
            "sword": pygame.image.load("minting/sword.png").convert_alpha(),
            "axe": pygame.image.load("minting/axe.png").convert_alpha(),
            "hand": pygame.image.load("minting/hand.png").convert_alpha()
        }

        self.base_weapon_damage = {
            'hand': 5,
            'axe': 15,
            'sword':300
        }
        self.weapon_damage = self.base_weapon_damage.copy()
        self.update_weapon_damage()
        self.weapon_range = {
            'hand': 30,
            'axe': 40,
            'sword': 50
        }
        self.stats = {
            "zombie_kills": 0,
            "wood_collected": 0,
            "fruit_collected": 0,
            "days_survived": 0,
            "fish_collected": 0,
            "crystals_collected": 0
        }


        # Fixed HP Bar Loading (330x30 sprite sheet with 5 frames)

        self.hp_frames = {
            100:pygame.image.load("haojun/image/hp.100.png").convert_alpha(),
            90: pygame.image.load("haojun/image/hp.90.png").convert_alpha(),
            80: pygame.image.load("haojun/image/hp.80.png").convert_alpha(),
            70: pygame.image.load("haojun/image/hp.70.png").convert_alpha(),
            60: pygame.image.load("haojun/image/hp.60.png").convert_alpha(),
            50: pygame.image.load("haojun/image/hp.50.png").convert_alpha(),
            40: pygame.image.load("haojun/image/hp.40.png").convert_alpha(),
            30: pygame.image.load("haojun/image/hp.30.png").convert_alpha(),
            20: pygame.image.load("haojun/image/hp.20.png").convert_alpha(),
            10: pygame.image.load("haojun/image/hp.10.png").convert_alpha(),
            0 : pygame.image.load("haojun/image/hp.0.png").convert_alpha(),
        }
        self.exp_bar_frames = {
            0: pygame.image.load("haojun/image/exp 0.png").convert_alpha(),
            20: pygame.image.load("haojun/image/exp 20.png").convert_alpha(),
            40: pygame.image.load("haojun/image/exp 40.png").convert_alpha(),
            60: pygame.image.load("haojun/image/exp 60.png").convert_alpha(),
            80: pygame.image.load("haojun/image/exp 80.png").convert_alpha(),
            100: pygame.image.load("haojun/image/exp 100.png").convert_alpha(),
        }
        self.chop_sounds = [
            pygame.mixer.Sound("haojun/chop1.wav"),
            pygame.mixer.Sound("haojun/chop2.wav"),
            pygame.mixer.Sound("haojun/chop3.wav")
        ]
        self.attack_sound = pygame.mixer.Sound("haojun/player_attack_sound.wav")

        self.walk_sheet = pygame.image.load("minting/character.png").convert_alpha()
        self.walk_down = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 0, 3)
        self.walk_up = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 1, 4)
        self.walk_left = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 2, 4)
        self.walk_right = load_frames(self.walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 3, 4)
       
        self.hairclip_walk_sheet = pygame.image.load("minting/fishbonewalk.png").convert_alpha()
        self.hairclip_walk_down = load_frames(self.hairclip_walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 0, 3)
        self.hairclip_walk_up = load_frames(self.hairclip_walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 1, 4)
        self.hairclip_walk_left = load_frames(self.hairclip_walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 2, 4)
        self.hairclip_walk_right = load_frames(self.hairclip_walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 3, 4)

        self.zombieskin_walk_sheet = pygame.image.load("minting/zombieskin.png").convert_alpha()
        self.zombieskin_walk_down = load_frames(self.zombieskin_walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 0, 3)
        self.zombieskin_walk_up = load_frames(self.zombieskin_walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 1, 4)
        self.zombieskin_walk_left = load_frames(self.zombieskin_walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 2, 4)
        self.zombieskin_walk_right = load_frames(self.zombieskin_walk_sheet, FRAME_WIDTH, FRAME_HEIGHT, 3, 4)

        self.attack_sheets = {
            'hand': pygame.image.load("minting/hand_attack.png").convert_alpha(),
            'axe': pygame.image.load("minting/axe_attack.png").convert_alpha(),
            'sword': pygame.image.load("minting/sword_attack.png").convert_alpha()
        }
        
        self.attack_frames = {
            'hand': {
                'right': load_frames(self.attack_sheets['hand'], FRAME_WIDTH, FRAME_HEIGHT, 0, 2),
                'left': load_frames(self.attack_sheets['hand'], FRAME_WIDTH, FRAME_HEIGHT, 1, 2)
            },
            'axe': {
                'right': load_frames(self.attack_sheets['axe'], FRAME_WIDTH, FRAME_HEIGHT, 0, 2),
                'left': load_frames(self.attack_sheets['axe'], FRAME_WIDTH, FRAME_HEIGHT, 1, 2)
            },
            'sword': {
                'right': load_frames(self.attack_sheets['sword'], FRAME_WIDTH, FRAME_HEIGHT, 0, 4),
                'left': load_frames(self.attack_sheets['sword'], FRAME_WIDTH, FRAME_HEIGHT, 1, 4)
            }
        }

        
        self.hairclip_attack_sheets = {
            'hand': pygame.image.load("minting/hairclip_hand_attack.png").convert_alpha(),
            'axe': pygame.image.load("minting/hairclip_axe_attack.png").convert_alpha(),
            'sword': pygame.image.load("minting/hairclip_sword_attack.png").convert_alpha()
        }

        self.hairclip_attack_frames = {
            'hand': {
                'right': load_frames(self.hairclip_attack_sheets['hand'], FRAME_WIDTH, FRAME_HEIGHT, 0, 2),
                'left': load_frames(self.hairclip_attack_sheets['hand'], FRAME_WIDTH, FRAME_HEIGHT, 1, 2)
            },
            'axe': {
                'right': load_frames(self.hairclip_attack_sheets['axe'], FRAME_WIDTH, FRAME_HEIGHT, 0, 2),
                'left': load_frames(self.hairclip_attack_sheets['axe'], FRAME_WIDTH, FRAME_HEIGHT, 1, 2)
            },
            'sword': {
                'right': load_frames(self.hairclip_attack_sheets['sword'], FRAME_WIDTH, FRAME_HEIGHT, 0, 4),
                'left': load_frames(self.hairclip_attack_sheets['sword'], FRAME_WIDTH, FRAME_HEIGHT, 1, 4)
            }
        }

        self.zombieskin_attack_sheets = {
            'hand': pygame.image.load("minting/zombie_hand.png").convert_alpha(),
            'axe': pygame.image.load("minting/zombie_axe.png").convert_alpha(),
            'sword': pygame.image.load("minting/zombie_sword.png").convert_alpha()
        }

        self.zombieskin_attack_frames = {
            'hand': {
                'right': load_frames(self.zombieskin_attack_sheets['hand'], FRAME_WIDTH, FRAME_HEIGHT, 0, 2),
                'left': load_frames(self.zombieskin_attack_sheets['hand'], FRAME_WIDTH, FRAME_HEIGHT, 1, 2)
            },
            'axe': {
                'right': load_frames(self.zombieskin_attack_sheets['axe'], FRAME_WIDTH, FRAME_HEIGHT, 0, 2),
                'left': load_frames(self.zombieskin_attack_sheets['axe'], FRAME_WIDTH, FRAME_HEIGHT, 1, 2)
            },
            'sword': {
                'right': load_frames(self.zombieskin_attack_sheets['sword'], FRAME_WIDTH, FRAME_HEIGHT, 0, 4),
                'left': load_frames(self.zombieskin_attack_sheets['sword'], FRAME_WIDTH, FRAME_HEIGHT, 1, 4)
            }
        }
         
        self.dead = False
        self.death_frame_index = 0
        self.death_frame_timer = 0
        self.time_of_death = 0
        self.respawn_delay = 3000  # 3 seconds

        # Load hairclip spritesheet and extract one frame to stick on head
        # nothing equipped by default
        self.equipped_hairclip = None
        self.equipped_zombieskin = None  
        self.show_animation = False
         
        

        # Load death animation (you can change the image path and frame count as needed)
        death_sheet = pygame.image.load("minting/die.png").convert_alpha()
        self.death_frames = load_frames(death_sheet, FRAME_WIDTH, FRAME_HEIGHT, 0, 25)

    def play_chop_sound(self):
        random.choice(self.chop_sounds).play()

    def equip_hairclip(self, name):
        self.equipped_hairclip = name

    def unequip_hairclip(self):
        print("Removing hairclip from character")
        self.equipped_hairclip = None

    def get_current_hairclip_sprite(self):
        if not self.equipped_hairclip:
            return None
        
        if self.attacking:
            idx = min(self.attack_frame, len(self.hairclip_attack_frames[self.current_weapon]['right']) - 1)
            side = 'left' if self.direction == 'left' else 'right'
            return self.hairclip_attack_frames[self.current_weapon][side][idx]
        else:
            frames = self.hairclip_walk_frames[self.direction]
            frame_idx = self.frame % len(frames)
            return frames[frame_idx]
        
    def equip_zombieskin(self, name):
        self.equipped_zombieskin = name

    def unequip_zombieskin(self):
        print("Removing costume from character")
        self.equipped_zombieskin = None

    def get_current_zombieskin_sprite(self):
        if not self.equipped_zombieskin:
            return None
        
        if self.attacking:
            idx = min(self.attack_frame, len(self.zombieskin_attack_frames[self.current_weapon]['right']) - 1)
            side = 'left' if self.direction == 'left' else 'right'
            return self.zombieskin_attack_frames[self.current_weapon][side][idx]
        else:
            frames = self.zombieskin_walk_frames[self.direction]
            frame_idx = self.frame % len(frames)
            return frames[frame_idx]

    def move(self, keys, dt):
        move_distance = self.speed * dt 
        moving = False

        zombieskin_sprite = None
        hairclip_sprite = None
        current_sprite = None

        if self.dead:
            self.update_death()
            if self.death_frame_index < len(self.death_frames):
                return self.position, self.death_frames[self.death_frame_index], None, None
            else:
                return self.position, self.death_frames[-1], None, None

        if self.attacking:
            self.rect.center = (self.position.x, self.position.y)
            return self.position, self.get_attack_sprite(),(self.get_zombieskin_frame() if self.equipped_zombieskin else None),(self.get_hairclip_frame() if self.equipped_hairclip else None)

        if keys[pygame.K_w]:
            self.position.y -= move_distance
            self.direction = 'up'
            moving = True
        if keys[pygame.K_s]:
            self.position.y += move_distance
            self.direction = 'down'
            moving = True
        if keys[pygame.K_a]:
            self.position.x -= move_distance
            self.direction = 'left'
            moving = True
        if keys[pygame.K_d]:
            self.position.x += move_distance
            self.direction = 'right'
            moving = True

        if moving:
            current_time = pygame.time.get_ticks()
            if current_time - self.last_frame_time > self.frame_speed * 1000:
                self.frame = (self.frame + 1) % len(self.walk_down)  
                self.last_frame_time = current_time

            current_sprite = self.get_current_sprite()
            hairclip_sprite = self.get_hairclip_frame() if self.equipped_hairclip else None
            zombieskin_sprite = self.get_zombieskin_frame() if self.equipped_zombieskin else None
        else:
            self.frame = 0
            current_sprite = self.walk_down[0]
            zombieskin_sprite = self.zombieskin_walk_down[0] if self.equipped_zombieskin else None
            hairclip_sprite = self.hairclip_walk_down[0] if self.equipped_hairclip else None

        self.rect.center = (self.position.x, self.position.y)

        return self.position, current_sprite, hairclip_sprite, zombieskin_sprite

    def switch_weapon(self, key):
        if key == pygame.K_TAB:
            current_index = self.weapons.index(self.current_weapon)
            next_index = (current_index + 1) % len(self.weapons)
            self.current_weapon = self.weapons[next_index]

    def attack(self, trees, zombies):
        if not self.attacking:
            self.current_attack_targets.clear()
            return None

        sprite = self.get_attack_sprite()
        current_attack_frames = self.attack_frames[self.current_weapon]

        if self.direction == 'left':
            max_frames = len(current_attack_frames['left'])
        else:
            max_frames = len(current_attack_frames['right'])

        if self.attack_frame // 2 >= max_frames:
            self.attacking = False
            self.attack_frame = 0
            self.attack_sound_played = False
            self.current_attack_targets.clear()
            return None

        # Trigger hit on frame 1
        if self.attack_frame // 2 == 1:
            attack_rect = self.get_attack_rect(50)
            hit_tree = False

            if self.current_weapon == 'axe':
                for tree in trees + trees_2:
                    if attack_rect.colliderect(tree.get_hitbox()) and not tree.was_hit:
                        hit_tree = True
                        self.play_chop_sound()
                        tree.start_animation()
                        tree.was_hit = True
                        self.add_exp(5)
                        inventory.add_item("Wood", 1)
                        self.stats["wood_collected"] += 1
                        print("Wood collected:", self.stats["wood_collected"])
                        self.achievement_system.check_achievements(self, self.stats)

                        if tree in trees_2:
                            inventory.add_item("Fruit", 1)
                            self.stats["fruit_collected"] += 1
                            print("Fruit collected:", self.stats["fruit_collected"])
                            self.achievement_system.check_achievements(self, self.stats)

                        tree.update(pygame.time.get_ticks() / 1000)

            if not hit_tree and not self.attack_sound_played:
                self.attack_sound.play()
                self.attack_sound_played = True

                if self.current_weapon == 'sword':
                    for zombie in zombies:
                        if attack_rect.colliderect(zombie.rect) and zombie not in self.current_attack_targets:
                            damage = self.weapon_damage[self.current_weapon]
                            killed = zombie.take_damage(damage, self.position)
                            if killed:
                                self.stats["zombie_kills"] += 1
                                self.achievement_system.check_achievements(self, self.stats)
                                print("Zombie kills:", self.stats["zombie_kills"])
                            self.current_attack_targets.append(zombie)
                else:
                    if not self.current_attack_targets:
                        for zombie in zombies:
                            if attack_rect.colliderect(zombie.rect):
                                damage = self.weapon_damage[self.current_weapon]
                                killed = zombie.take_damage(damage, self.position)
                                if killed:
                                    self.stats["zombie_kills"] += 1
                                    self.achievement_system.check_achievements(self, self.stats)
                                    print("Zombie kills:", self.stats["zombie_kills"])
                                self.current_attack_targets.append(zombie)
                                break

                if attack_rect.colliderect(boss.rect) and boss not in self.current_attack_targets:
                    damage = self.weapon_damage[self.current_weapon]
                    boss.take_damage(damage)
                    self.current_attack_targets.append(boss)

        # Control attack frame timing
        if self.attack_frame_counter >= self.attack_frame_delay:
            self.attack_frame += 1
            self.attack_frame_counter = 0
        else:
            self.attack_frame_counter += 1

        return sprite
    
    def get_attack_sprite(self):
        idx = self.attack_frame // 2
        max_idx = len(self.attack_frames[self.current_weapon]['right']) - 1
        idx = min(idx, max_idx)
        
        if self.direction == 'left':
            return self.attack_frames[self.current_weapon]['left'][idx]
        else:
            return self.attack_frames[self.current_weapon]['right'][idx]
    
    def get_attack_rect(self, range):
        range = int(range * character_scale)
        size = int(40 * character_scale)
        
        if self.direction == 'up':
            return pygame.Rect(self.position.x - size//2, self.position.y - range, size, range)
        elif self.direction == 'down':
            return pygame.Rect(self.position.x - size//2, self.position.y, size, range)
        elif self.direction == 'left':
            return pygame.Rect(self.position.x - range, self.position.y - size//2, range, size)
        elif self.direction == 'right':
            return pygame.Rect(self.position.x, self.position.y - size//2, range, size)

    def get_current_sprite(self):
        sprite_list = {
            'up': self.walk_up,
            'down': self.walk_down,
            'left': self.walk_left,
            'right': self.walk_right
        }[self.direction]

        frame_index = int(self.frame) % len(sprite_list)
        return sprite_list[frame_index]

    def take_damage(self, amount):
        if self.dead:
            return

        # Apply armor reduction if available
        armor_reduction_factor = self.get_armor_reduction_factor()
        reduced_amount = int(amount * armor_reduction_factor)

        self.health -= reduced_amount

        print(f"[DEBUG] Player took {reduced_amount} damage (original: {amount}, reduction factor: {armor_reduction_factor})")

        if self.health <= 0:
            self.health = 0
            self.dead = True
            self.death_frame_index = 0
            self.death_frame_timer = pygame.time.get_ticks()
            self.time_of_death = pygame.time.get_ticks()

    def respawn(self):
        self.max_health = 100
        self.health = 100
        self.exp = 0
        self.dead = False
        self.attacking = False
        self.attack_frame = 0
        self.frame = 0
        self.position = pygame.Vector2(1500, 125)  
        self.level = 1
        self.exp_to_next_level = 50
        self.update_weapon_damage()  # Add this line to reset weapon damage
        
    def update_death(self):
        current_time = pygame.time.get_ticks()
        if self.death_frame_index < len(self.death_frames):
            if current_time - self.death_frame_timer > 150:
                self.death_frame_timer = current_time
                self.death_frame_index += 1
        else:
            if current_time - self.time_of_death >= self.respawn_delay:
                self.respawn()

    def draw_health_bar(self, surface): 
        if self.dead:
            return
        bar_width = 200
        bar_height = 20
        x = (surface.get_width() - bar_width) // 2
        y = surface.get_height() - bar_height - 10  # Bottom of screen


        # Round to nearest 10
        hp_percent = int((self.health / self.max_health) * 100)
        hp_percent = min(max(hp_percent, 0), 100)

        # Optional: round down to nearest 10 if you only have images per 10%
        hp_frame_level = (hp_percent // 10) * 10

        current_frame = self.hp_frames.get(hp_frame_level, self.hp_frames[0])

        # No need to scale unless needed
        # If too small visually, you can still scale like this:
        scale_factor = 2
        scaled_frame = pygame.transform.scale(current_frame, (
            current_frame.get_width() * scale_factor,
            current_frame.get_height() * scale_factor
        ))

        x = (surface.get_width() - scaled_frame.get_width()) // 2
        y = surface.get_height() - scaled_frame.get_height() + 60
        surface.blit(scaled_frame, (x, y))

        # HP number
        health_text = font.render(f"{int(self.health)}/{(self.max_health)}", True, (255, 255, 255))
        text_x = x + scaled_frame.get_width() + 10
        text_y = y + (scaled_frame.get_height() - health_text.get_height()) // 2
        surface.blit(health_text, (text_x, text_y))
        

        # Load sprite sheet

    def load_frames(self):
        frame_width = self.spritesheet.get_width() // self.cols
        frame_height = self.spritesheet.get_height() // self.rows
        frames = []
        for row in range(self.rows):
            for col in range(self.cols):
                frame = self.spritesheet.subsurface(
                    pygame.Rect(col * frame_width, row * frame_height, frame_width, frame_height)
                )
                frames.append(frame)
        return frames

    def is_player_inside(self, player_pos):
        dx = (player_pos[0] - self.center[0]) / self.detection_radius_x
        dy = (player_pos[1] - self.center[1]) / self.detection_radius_y
        return dx * dx + dy * dy <= 1

    def update(self, player_pos, keys):
        if self.is_player_inside(player_pos) and keys[pygame.K_j]:
            self.show_animation = True
            self.current_frame = 0  # Restart animation

        if self.show_animation:
            now = pygame.time.get_ticks()
            if now - self.last_update > self.frame_delay:
                self.current_frame += 1
                self.last_update = now
                if self.current_frame >= len(self.frames):
                    self.current_frame = 0
                    self.show_animation = False  # Stop after one loop
                    
        if self.speed_timer and time.time() > self.speed_timer:
            self.speed = self.original_speed
            self.speed_timer = 0

    def draw(self, screen, offset):
        # get base sprite (player)
        player_sprite = self.get_current_sprite()  # You have this method
        # get zombieskin sprite
        zombieskin_sprite = self.get_zombieskin_frame()
        # get hairclip sprite
        hairclip_sprite = self.get_hairclip_frame()

        # Draw player
        screen.blit(player_sprite, self.rect.topleft - offset)

        if zombieskin_sprite:
            screen.blit(zombieskin_sprite, self.rect.topleft - offset)
        # Draw hairclip if equipped
        if hairclip_sprite:
            screen.blit(hairclip_sprite, self.rect.topleft - offset)



    def calculate_exp_needed(self, level):
        # You can tweak the formula for difficulty scaling
        return 45 * level

    def add_exp(self, amount):
        if self.level >= 20:
            return  # Stop gaining experience at level 20
        
        self.exp += amount
        while self.exp >= self.exp_to_next_level:
            self.exp -= self.exp_to_next_level
            self.level += 1
            self.exp_to_next_level = self.calculate_exp_needed(self.level)
            print(f"{self.username} leveled up to level {self.level}!")  # optional: restore HP on level-up
            self.max_health = 100 * self.level  # or any formula you like
            self.health = self.max_health       # optionally heal to full on level up
            self.update_weapon_damage()  
    
    def draw_exp_bar(self, surface):
        if self.dead:
            return

        percent = int((self.exp / self.exp_to_next_level) * 100)
        percent = max(0, min(100, (percent // 10) * 10))  # Round to nearest 10%

        rounded_percent = min(self.exp_bar_frames.keys(), key=lambda k: abs(k - percent))
        bar_img = self.exp_bar_frames[rounded_percent]

        scale_factor = 2
        scaled_img = pygame.transform.scale(bar_img, (
            bar_img.get_width() * scale_factor,
            bar_img.get_height() * scale_factor
        ))

        x = (surface.get_width() - scaled_img.get_width()) // 2
        y = surface.get_height() - scaled_img.get_height() + 30
        surface.blit(scaled_img, (x, y))

        # Level text
        level_text = font.render(f"Level {self.level}", True, (255, 255, 0))
        surface.blit(level_text, (x + scaled_img.get_width() - 120, y + 50))
    
    def update_weapon_damage(self):
        level = self.level
        multiplier = self.attack_multipliers[min(level, len(self.attack_multipliers)-1)]

        for weapon in self.weapon_damage:
            base_damage = self.base_weapon_damage[weapon]
            self.weapon_damage[weapon] = int(base_damage * multiplier)

    def gain_health(self, amount):
        self.health += amount
        if self.health > self.max_health:
            self.health = self.max_health
        print(f"Health restored! Current health: {self.health}")

    def get_zombieskin_frame(self):
        if not self.equipped_zombieskin:
            return None

        if self.attacking:
            weapon = self.current_weapon
            direction = 'left' if self.direction == 'left' else 'right'  # Attacks only have left/right
            
            # Get the attack frames for current weapon
            weapon_frames = self.zombieskin_attack_frames.get(weapon, {}).get(direction, [])
            
            if not weapon_frames:
                print(f"[WARNING] No zombieskin attack frames for {weapon} {direction}")
                return None
                
            # Calculate frame index based on attack progress
            frame_index = min(self.attack_frame // 2, len(weapon_frames) - 1)
            return weapon_frames[frame_index]
        else:
            # Walking frames
            if self.direction == 'up':
                frames = self.zombieskin_walk_up
            elif self.direction == 'down':
                frames = self.zombieskin_walk_down
            elif self.direction == 'left':
                frames = self.zombieskin_walk_left
            elif self.direction == 'right':
                frames = self.zombieskin_walk_right
            else:
                return None
                
            frame_index = self.frame % len(frames)
            return frames[frame_index]
        
    def get_hairclip_frame(self):
        if not self.equipped_hairclip:
            return None

        if self.attacking:
            frame_index = self.attack_frame

            # Get frames for current weapon
            weapon_clips = self.hairclip_attack_frames.get(self.current_weapon, {})
            
            # Only 'left' and 'right' are supported
            if self.direction in weapon_clips:
                frames = weapon_clips[self.direction]
            else:
                # Fallback if direction is up/down
                fallback_direction = 'right' if 'right' in weapon_clips else 'left'
                frames = weapon_clips.get(fallback_direction, [])
            
            if not frames:
                print(f"[WARNING] No hairclip attack frames found for weapon '{self.current_weapon}', direction '{self.direction}'")
                return None

            frame_index %= len(frames)
            return frames[frame_index]
        else:
            if self.direction == 'up':
                frames = self.hairclip_walk_up
            elif self.direction == 'down':
                frames = self.hairclip_walk_down
            elif self.direction == 'left':
                frames = self.hairclip_walk_left
            elif self.direction == 'right':
                frames = self.hairclip_walk_right
            else:
                return None

            frame_index = self.frame % len(frames)
            return frames[frame_index]
        

    def gain_speed(self, amount):
        self.speed += amount
        self.speed_timer = time.time() + duration
        print(f"[DEBUG] Speed increased by {amount} for {duration} seconds. Current speed: {self.speed}")


    # In the Player class, modify the perform_action method in InventoryMenu:
    def perform_action(self, action, index):
        item = self.inventory.slots[index]
        if not item:
            print("No item in slot!")
            return

        name, count = item
        
        #food only
        if action == "eat" and self.inventory.item_icons[name]["category"] == "food":
            if name == "Fish Soup":
                self.gain_health(50)
            elif name == "Grilled Fish":
                self.gain_health(120)
            elif name == "Special Dish":
                self.gain_health(200)
            elif name == "Fruit Jam":
                self.gain_speed(1.5, duration = 20)
            elif name == "Reef Medly":
                self.gain_health(200)
                self.gain_speed(1.5, duration = 30)
            elif name == "Twinfin Delight":
                self.gain_health(300)
            self.inventory.remove_item(index, 1)
            
        elif name == "Fruit" and action == "eat":
            self.gain_health(5)
            self.inventory.remove_item(index, 1)
        elif action == "drop":
            self.inventory.remove_item(index, 1)
        elif action == "use":
            print(f"Using {name}")
            self.inventory.remove_item(index, 1)

    def get_armor_reduction_factor(self):
        reduction = 1.0  # Default: full damage
        for armor_name, factor in ARMOR_PROTECTION.items():
            if inventory.has_item(armor_name) and factor < reduction:
                reduction = factor
        return reduction
    

class AchievementSystem:
    def __init__(self, on_unlock_callback=None, inventory=None):
        print(f"⚠️ NEW ACHIEVEMENT SYSTEM CREATED ⚠️ ID: {id(self)}")
        self.achievements = {
            "First Kill": False,
            "Zombie Slayer (20 kills)": False,
            "Level 5 Achieved": False,
            "Wood Collector (10 wood)": False,
            "Fruit Picker (5 fruit)": False,
            "Lumberjack (10 wood)": False,
            "Crystal Hunter (1 crystal)": False,
            "Fisherman (10 fish)": False
        }
        self.shown_achievements = set()
        self.on_unlock_callback = on_unlock_callback
        self.inventory = inventory
        print(f"[DEBUG] AchievementSystem created with callback: {self.on_unlock_callback}")

    def check_achievements(self, player, stats):
        if "Fisherman (10 fish)" not in self.achievements:
            print("[ERROR] Achievement missing! Resetting...")
            self.achievements["Fisherman (10 fish)"] = False  # Auto-repair
     
        if not self.achievements["First Kill"] and stats["zombie_kills"] >= 1:
            self.unlock("First Kill")
        if not self.achievements["Zombie Slayer (20 kills)"] and stats["zombie_kills"] >= 20:
            self.unlock("Zombie Slayer (20 kills)")
        if not self.achievements["Level 5 Achieved"] and player.level >= 5:
            self.unlock("Level 5 Achieved")
        if not self.achievements["Lumberjack (10 wood)"] and stats["wood_collected"] >= 10:
            self.unlock("Lumberjack (10 wood)")
        if not self.achievements["Fruit Picker (5 fruit)"] and stats["fruit_collected"] >= 5:
            self.unlock("Fruit Picker (5 fruit)")
        if not self.achievements["Fisherman (10 fish)"] and stats.get("fish_collected", 0) >=10:
            self.unlock("Fisherman (10 fish)")
        if not self.achievements["Crystal Hunter (1 crystal)"] and stats.get("crystals_collected", 0) >=1:
            self.unlock("Crystal Hunter (1 crystal)")
            

    def unlock(self, name):
        if self.achievements.get(name) and name in self.shown_achievements:
            return

        self.achievements[name] = True

        # 🎁 Add inventory reward for "First Kill"
        if name == "First Kill" and self.inventory:
            added = self.inventory.add_item("Armor(Iron)", 1)
            print(f"[DEBUG] inventory id in achievement unlock: {id(self.inventory)}")

            # Minimal debug: print all inventory slots after adding
            print("[DEBUG] Full inventory slots after adding Armor(Iron):")
            for i, slot in enumerate(self.inventory.slots):
                if slot:
                    print(f"  Slot {i}: {slot[0]} x{slot[1]}")
                else:
                    print(f"  Slot {i}: EMPTY")

            # Also print the first 5 visible slots (slots 0 to 4)
            print("[DEBUG] Visible inventory slots (0-4):")
            for i in range(5):
                slot = self.inventory.slots[i]
                if slot:
                    print(f"  Visible slot {i}: {slot[0]} x{slot[1]}")
                else:
                    print(f"  Visible slot {i}: EMPTY")
                    
        if name == "Fisherman (15 fish)" and self.inventory:
            added = self.inventory.add_item("FishBone_Clip", 1)
            print(f"[DEBUG] Added FishBone_Clip to inventory for achievement: {name}")

        if name == "Zombie Slayer (20 kills)" and self.inventory:
                    added = self.inventory.add_item("ZombiePaw", 1)
                    print(f"[DEBUG] Added FishBone_Clip to inventory for achievement: {name}")
        
        if name not in self.shown_achievements:
            if self.on_unlock_callback:
                try:
                    self.on_unlock_callback(name)
                    self.shown_achievements.add(name)
                    print(f"🎉 Achievement Unlocked: {name}")
                except Exception as e:
                    print(f"[ERROR] Callback failed: {e}")
            else:
                print("[WARNING] No unlock callback assigned!")

class AchievementDisplay:
    def __init__(self, font, screen):
        self.font = font
        self.screen = screen
        self.current_achievement = None
        self.display_start_time = 0
        self.display_duration = 3000  # ms

    def show(self, achievement_name):
        self.current_achievement = achievement_name
        self.display_start_time = pygame.time.get_ticks()

    def update(self):
        if self.current_achievement:
            current_time = pygame.time.get_ticks()
            if current_time - self.display_start_time < self.display_duration:
                text = f"Achievement Unlocked: {self.current_achievement}"
                text_surface = self.font.render(text, True, (255, 215, 0))
                rect = text_surface.get_rect(center=(self.screen.get_width() // 2, self.screen.get_height() // 2))
                self.screen.blit(text_surface, rect)
            else:
                self.current_achievement = None

class AchievementPage:
    def __init__(self,window_size, achievement_system, font=None):
        self.visible = False
        self.achievement_system = achievement_system
        self.screen_size = screen_size
        self.font = font or pygame.font.SysFont(None, 28)
        self.title_font = pygame.font.SysFont(None, 40)
        self.window_size = window_size
        self.achievement_icons = {
            "First Kill": trim_surface(pygame.image.load("haojun/image/first_kill.png")),
            "Zombie Slayer (20 kills)": trim_surface(pygame.image.load("haojun/image/zombie_slayer.png")),
            "Level 5 Achieved": trim_surface(pygame.image.load("haojun/image/level5.png")),
            "Lumberjack (10 wood)": trim_surface(pygame.image.load("haojun/image/lumberjack.png")),
            "Fruit Picker (5 fruit)": trim_surface(pygame.image.load("haojun/image/fruit_picker.png")),
            "Fisherman (10 fish)": trim_surface(pygame.image.load("haojun/image/fisherman.png")),
            "Crystal Hunter (1 crystal)": trim_surface(pygame.image.load("haojun/image/crystal_hunter.png")),
            # Add more as needed
        }
    
    def draw(self, screen):
        w, h = self.window_size

        overlay = pygame.Surface((w, h), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        screen.blit(overlay, (0, 0))

        title = self.title_font.render("Achievements", True, (255, 255, 255))
        screen.blit(title, (w // 2 - title.get_width() // 2, 50))

        start_x = 100
        start_y = 120
        spacing = 80
        icon_size = 64
        padding = 10
        cols = (w - 2 * start_x) // (icon_size + padding)

        mouse_pos = pygame.mouse.get_pos()
        self.hovered_achievement = None

        idx = 0
        for name, unlocked in self.achievement_system.achievements.items():
            if unlocked:
                row = idx // cols
                col = idx % cols
                icon = self.achievement_icons.get(name)

                if icon:
                    icon = pygame.transform.scale(icon, (64, 64))
                    x = start_x + col * (icon_size + padding)
                    y = start_y + row * (icon_size + padding)
                    screen.blit(icon, (x, y))

                    # Check for mouse hover
                    icon_rect = pygame.Rect(x, y, icon.get_width(), icon.get_height())
                    if icon_rect.collidepoint(mouse_pos):
                        self.hovered_achievement = name

                idx += 1

        # Draw hover text if applicable
        if self.hovered_achievement:
            tooltip = self.font.render(self.hovered_achievement, True, (255, 255, 255))
            tooltip_rect = tooltip.get_rect(topleft=(mouse_pos[0] + 15, mouse_pos[1] + 10))
            pygame.draw.rect(screen, (0, 0, 0), tooltip_rect.inflate(10, 6))
            screen.blit(tooltip, tooltip_rect)

    def update_layout(self, window_size):
        self.window_size = window_size
        self.window_rect = pygame.Rect(
            self.window_size[0] // 2 - 250,
            self.window_size[1] // 2 - 200,
            500, 400
        )

user_system = UserSystem()  # Create UserSystem instance
speed = 2.5  # Adjust as needed
player_position = pygame.Vector2(1500, 125)

class HouseUI:
    def __init__(self):
        self.elements = []
        self.background = house_image
    
    def add_button(self, rect, text, action):
        self.elements.append({
            "type": "button",
            "rect": rect,
            "text": text,
            "action": action
        })
    
    def draw(self, surface):
        surface.blit(self.background, (0, 0))
        for element in self.elements:
            if element["type"] == "button":
                pygame.draw.rect(surface, (200, 200, 200), element["rect"])
                text = font.render(element["text"], True, (0, 0, 0))
                text_rect = text.get_rect(center=element["rect"].center)
                surface.blit(text, text_rect)
    
    def handle_click(self, pos):
        for element in self.elements:
            if element["type"] == "button" and element["rect"].collidepoint(pos):
                element["action"]()
                return True
        return False

# Initialize
house_ui = HouseUI()
house_ui.add_button(pygame.Rect(100, 100, 200, 50), "Exit House", lambda: globals().update({"in_house": False}))

class Tree:
    def __init__(self, position, frames):
        self.position = pygame.Vector2(position)
        self.frames = frames
        self.index = 0
        self.animating = False
        self.animation_speed = 0.2
        self.last_update_time = 0
        self.hold_duration = 10
        self.hold_start_time = 0
        self.is_holding = False
        self.frame_width = 100
        self.frame_height = 100

        self.was_hit = False  # To track if the tree has been hit
        self.hit_timer = 0  # Timer for cooldown
        self.hit_cooldown = 0.3  # cooldown before tree can be hit again

        
    def start_animation(self):
        if not self.animating and not self.is_holding:
            self.animating = True
            self.index = 0
            self.last_update_time = pygame.time.get_ticks() / 1000

    def update(self, current_time):
        if self.animating:
            if current_time - self.last_update_time > self.animation_speed:
                self.index += 1
                self.last_update_time = current_time
                if self.index >= 6:
                    self.index = 6
                    self.animating = False
                    self.is_holding = True
                    self.hold_start_time = current_time
        elif self.is_holding:
            if current_time - self.hold_start_time > self.hold_duration:
                self.is_holding = False
                self.index = 0
                self.index = 0
                self.was_hit = False  # reset hit status


        if self.was_hit:
            self.hit_timer += current_time - self.last_update_time
            if self.hit_timer >= self.hit_cooldown:
                self.was_hit = False  # Reset after cooldown
                self.hit_timer = 0  # Reset the timer



    def get_hitbox(self):
        hitbox_height = 20
        return pygame.Rect(
            self.position.x + 20,
            self.position.y + 100 - hitbox_height,
            100 - 40,
            hitbox_height
        )

    def draw(self, surface, camera):
        pos_on_surface = self.position - pygame.Vector2(camera.topleft)
        surface.blit(self.frames[self.index], pos_on_surface)

# Regular trees (wood only)
tree_sheet = pygame.image.load("images/map-sprite/tree-new.png").convert_alpha()
tree_frames = load_frames(tree_sheet, 100, 100, 0, 7, spacing=5)
trees = []
for _ in range(20):
    valid_position = False
    attempts = 0
    while not valid_position and attempts < 100:  # Try 100 times max
        x = random.randint(0, map_image.get_width() - 100)
        y = random.randint(0, map_image.get_height() - 100)
        tree_center = (x + 50, y + 50)  # Check the tree's center point
        if is_valid_tree_position(tree_center, tree_restricted_zones):
            trees.append(Tree((x, y), tree_frames))
            valid_position = True
        attempts += 1

# Fruit trees (wood + fruit)
tree_sheet_2 = pygame.image.load("images/map-sprite/tree-fruit.png").convert_alpha()
tree_frames_2 = load_frames(tree_sheet_2, 100, 100, 0, 7, spacing=5)
trees_2 = []
for _ in range(20):
    valid_position = False
    attempts = 0
    while not valid_position and attempts < 100:
        x = random.randint(0, map_image.get_width() - 100)
        y = random.randint(0, map_image.get_height() - 100)
        tree_center = (x + 50, y + 50)
        if is_valid_tree_position(tree_center, tree_restricted_zones):
            trees_2.append(Tree((x, y), tree_frames_2))
            valid_position = True
        attempts += 1

class Zombie(pygame.sprite.Sprite):
    def __init__(self, x, y, player):
        super().__init__()
        self.image = zombie_img.copy()
        self.idle_image = zombie_img.copy()
        self.image = self.idle_image
        self.rect = self.image.get_rect(center=(x, y))
        self.position = pygame.Vector2(x, y)  # Add Vector2 position tracking
        self.player = player
        self.speed = 1.5
        self.attack_range = 30
        self.attack_damage = 30
        self.last_attack_time = 0
        self.attack_cooldown = 1
        self.attack_windup_time = 0.3
        self.windup_start_time = None
        self.hp = 100
        self.max_hp = 100
        self.is_moving = False
        self.facing_left = False

        self.walk_images = zombie_walk_images
        self.attack_images = zombie_attack_images
        self.die_images = zombie_die_images

        self.animation_index = 0
        self.last_animation_time = time.time()
        self.animation_speed = 0.2

        self.is_wandering = True
        self.wander_direction = pygame.Vector2(random.uniform(-1, 1), random.uniform(-1, 1)).normalize()#let the zombie have the same speed while wandering
        self.last_wander_time = time.time()
        self.wander_interval = 2
        self.pause_duration = 2

        self.state = "idle"
        self.is_dead = False
        self.death_time = 0
        self.death_duration = 1
        self.chase_range = 90
        self.die_sound = pygame.mixer.Sound("haojun/zombie_die_sound.wav")

    def update_facing_direction(self):
        self.image = pygame.transform.flip(self.image, self.facing_left, False)

    def update(self):
        current_time = time.time()

        if self.is_dead:
            if current_time - self.last_animation_time > self.animation_speed:
                self.animation_index += 1
                if self.animation_index < len(self.die_images):
                    self.image = self.die_images[self.animation_index]
                    self.update_facing_direction()
                else:
                    self.image = self.die_images[-1]
                self.last_animation_time = current_time

            if current_time - self.death_time > self.death_duration:
                self.kill()
            return

        # Get player position (works with both Vector2 and rect)
        player_pos = getattr(self.player, 'position', pygame.Vector2(self.player.rect.center))#this can check if the player is using rect.center or Vector 2
        
        # Calculate direction vector
        direction = player_pos - self.position#use hypothenius to calculate the distance
        distance = direction.length()
        
        # Update facing direction
        self.facing_left = direction.x < 0

        # Attack state handling
        if self.state == "attack":
            if self.windup_start_time:
                if current_time - self.windup_start_time >= self.attack_windup_time:
                    self.apply_attack_damage()
                    self.windup_start_time = None

            if current_time - self.last_animation_time > self.animation_speed:
                self.animation_index += 1
                if self.animation_index < len(self.attack_images):
                    self.image = self.attack_images[self.animation_index]
                    self.update_facing_direction()
                else:
                    self.state = "walk"
                    self.animation_index = 0
                self.last_animation_time = current_time
            return

        # Movement logic
        if distance < self.chase_range:
            if distance > self.attack_range:
                # Chase player
                if distance > 0:
                    direction = direction.normalize()#prevent if the distance is longer the zombie will walk faster
                self.position += direction * self.speed
                self.is_moving = True
            elif current_time - self.last_attack_time >= self.attack_cooldown:
                self.start_attack()
        else:
            # Wandering behavior
            if self.is_wandering:
                self.position += self.wander_direction * self.speed * 0.5
                self.is_moving = True

                if current_time - self.last_wander_time > self.wander_interval:
                    self.is_wandering = False
                    self.last_wander_time = current_time
            else:
                self.is_moving = False
                if current_time - self.last_wander_time > self.pause_duration:
                    self.is_wandering = True
                    self.last_wander_time = current_time
                    self.wander_direction = pygame.Vector2(random.uniform(-1, 1), random.uniform(-1, 1))
                    if self.wander_direction.length() > 0:
                        self.wander_direction = self.wander_direction.normalize()

        # Update rect position to match Vector2 position
        self.rect.center = (round(self.position.x), round(self.position.y))#use round since the rect.center only accept integer

        # Animation updates
        if self.is_moving:
            if current_time - self.last_animation_time > self.animation_speed:
                self.animation_index = (self.animation_index + 1) % len(self.walk_images)
                self.image = self.walk_images[self.animation_index]
                self.update_facing_direction()
                self.last_animation_time = current_time
        else:
            if self.state == "idle":
                self.image = self.idle_image
            elif self.state == "walk":
                if current_time - self.last_animation_time > self.animation_speed:
                    self.animation_index = (self.animation_index + 1) % len(self.walk_images)
                    self.image = self.walk_images[self.animation_index]
                    self.update_facing_direction()
                    self.last_animation_time = current_time

    def start_attack(self):
        self.state = "attack"
        self.animation_index = 0
        self.windup_start_time = time.time()
        self.last_attack_time = time.time()
        print("Zombie starts wind-up...")

    def apply_attack_damage(self):
        # Recheck distance before applying damage
        player_pos = getattr(self.player, 'position', pygame.Vector2(self.player.rect.center))
        distance = (player_pos - self.position).length()

        if distance <= self.attack_range:
            print("Zombie attacks!")
            self.player.take_damage(self.attack_damage)
        else:
            print("Attack missed — player moved out of range.")

    def take_damage(self, amount, attacker_pos=None):
        if self.is_dead:
            return False  # Already dead, no kill counted

        self.hp -= amount
        print(f"Zombie HP: {self.hp}")

        if attacker_pos is not None:
            direction = self.position - pygame.Vector2(attacker_pos)
            if direction.length() > 0:
                direction = direction.normalize()
                knockback_distance = 20
                self.position += direction * knockback_distance
                self.rect.center = (round(self.position.x), round(self.position.y))

        if self.hp <= 0 and not self.is_dead:
            print("Zombie died!")
            self.state = "die"
            self.animation_index = 0
            self.is_dead = True
            self.death_time = time.time()
            self.player.add_exp(25)
            self.die_sound.play()
            return True  # ✅ Killed!

        return False  # Still alive

    def draw_health_bar(self, surface, camera):
        if self.hp <= 0:  # Do not draw health bar if the zombie is dead
            return

        bar_width = 30
        bar_height = 5
        fill = (self.hp / self.max_hp) * bar_width  # Fill ratio based on health
        fill = max(0, min(fill, bar_width))  # Ensure the fill is clamped to the max width
        x = self.rect.centerx - bar_width // 2 - camera.x  # Centered above zombie, considering camera offset
        y = self.rect.top - 10 - camera.y  # Positioned above the zombie

        # Outer black border with rounded corners
        border_rect = pygame.Rect(x - 1, y - 1, bar_width + 2, bar_height + 2)
        pygame.draw.rect(surface, (0, 0, 0), border_rect, border_radius=3)

        # Red background bar
        bg_rect = pygame.Rect(x, y, bar_width, bar_height)
        pygame.draw.rect(surface, (255, 0, 0), bg_rect, border_radius=3)

        # Green health fill
        fill_rect = pygame.Rect(x, y, fill, bar_height)
        pygame.draw.rect(surface, (0, 255, 0), fill_rect, border_radius=3)

show_boat = False
boat_rect = pygame.Rect(418, 159, 100, 100)  # adjust size to match your boat image
show_press_j_message = False
game_ended = False
end_sprite_index = 0
end_sprite_timer = 0
end_sprite_speed = 0.15

boat_image = pygame.image.load("images/craft-icon/boat.png").convert_alpha()
end_game_frames = [pygame.image.load(f"images/map-sprite/tree-sprite.png").convert_alpha() for i in range(7)]
# REPLACE ENDING SPRITESHEET HERE AFTER DONE DRAWING!!! 😀😀😀

class Boss(pygame.sprite.Sprite):
    def __init__(self, x, y, player, area_rect):
        super().__init__()
        self.walk_images = boss_walk_frames
        self.attack_images = boss_attack_frames
        self.ult_image = boss_ult_frames
        self.death_images = boss_die_frames
        self.image = self.walk_images[0]
        self.rect = self.image.get_rect(center=(x, y))
        self.position = pygame.Vector2(x, y)
        self.player = player
        self.area_rect = area_rect
        self.speed = 1.75
        self.attack_range = 60
        self.attack_damage = 150
        self.last_attack_time = 0
        self.attack_cooldown = 1.2
        self.hp = 2500
        self.max_hp = 2500
        self.attack_duration = 0.5
        self.attack_animation_end_time = 0
        self.state = "idle"
        self.animation_index = 0
        self.last_animation_time = time.time()
        self.animation_speed = 0.15
        self.attack_count = 0
        self.is_using_ult = False
        self.ult_frame_index = 0
        self.ult_end_time = 0
        self.is_dead = False
        self.death_index = 0
        self.pending_attack = False
        self.facing_left = False
        self.attack_animation_active = False
        self.dodged = False  # Flag to prevent continuous dodge message
        self.attack_in_progress = False  # Flag to prevent multiple attacks per animation cycle

    def update(self):
        if self.is_dead:
            if self.handle_death():
                return
            return

        player_pos = pygame.Vector2(self.player.rect.center)
        direction = player_pos - self.position
        distance = direction.length()

        # Avoid jitter when directly on top of player
        if abs(direction.x) > 2:
            self.facing_left = direction.x < 0

        if self.is_using_ult:
            self.handle_ultimate()
        elif self.attack_animation_active:
            if time.time() >= self.attack_animation_end_time:
                self.attack_animation_active = False
                self.state = "idle"
                if self.pending_attack:
                    self.apply_attack_damage()
                    self.pending_attack = False
            else:
                # Check if the player dodged out of attack range during animation, but allow animation to continue
                self.handle_attack_dodge()

        elif distance <= self.attack_range and time.time() - self.last_attack_time >= self.attack_cooldown:
            self.attack_player()
        elif distance <= 200:
            self.move_toward_player(direction, distance)
        else:
            self.state = "idle"

        self.update_animation()

    def move_toward_player(self, direction, distance):
        if distance > self.attack_range - 5 and not self.attack_animation_active and not self.is_using_ult:
            direction = direction.normalize()
            new_pos = self.position + direction * self.speed
            if self.area_rect.collidepoint(new_pos):
                self.position = new_pos
                self.rect.center = (round(self.position.x), round(self.position.y))
                self.state = "chasing"

    def update_animation(self):
        current_time = time.time()
        if current_time - self.last_animation_time > self.animation_speed:
            if self.state == "chasing":
                self.animation_index = (self.animation_index + 1) % len(self.walk_images)
                image = self.walk_images[self.animation_index]
            elif self.state == "attacking":
                self.animation_index = (self.animation_index + 1) % len(self.attack_images)
                image = self.attack_images[self.animation_index]
            elif self.state == "ultimate":
                self.ult_frame_index = min(self.ult_frame_index + 1, len(self.ult_image) - 1)
                image = self.ult_image[self.ult_frame_index]
            elif self.state == "dying":
                image = self.death_images[min(self.death_index, len(self.death_images) - 1)]
            else:
                image = self.walk_images[0]

            if self.facing_left:
                image = pygame.transform.flip(image, True, False)

            self.image = image
            self.last_animation_time = current_time

    def attack_player(self):
        # Only attack if the player is within attack range and the attack isn't already in progress
        if self.attack_in_progress:
            return  # Prevent multiple attacks during the same attack animation cycle

        player_pos = pygame.Vector2(self.player.rect.center)
        distance = (player_pos - self.position).length()

        if distance <= self.attack_range:
            self.state = "attacking"
            self.attack_animation_active = True
            self.last_attack_time = time.time()
            self.attack_animation_end_time = self.last_attack_time + len(self.attack_images) * self.animation_speed
            self.pending_attack = True
            self.attack_in_progress = True  # Mark that an attack is in progress
            self.animation_index = 0
            self.last_animation_time = time.time()

            self.attack_count += 1
            if self.attack_count >= 3:
                self.trigger_ultimate()

    def handle_attack_dodge(self):
        """Check if the player has dodged out of range, but still allow the attack animation to continue."""
        if self.is_player_out_of_range() and not self.dodged:
            self.dodged = True
            print("Player dodged, but attack animation continues.")
        elif not self.is_player_out_of_range():
            self.dodged = False  # Reset dodged flag if player is back in range

    def is_player_out_of_range(self):
        """Check if the player has moved out of the attack range during the attack animation"""
        player_pos = pygame.Vector2(self.player.rect.center)
        distance = (player_pos - self.position).length()
        return distance > self.attack_range

    def apply_attack_damage(self):
        # Apply damage only when the player is still in range at the time of attack animation end
        player_pos = pygame.Vector2(self.player.rect.center)
        distance = (player_pos - self.position).length()
        if distance <= self.attack_range:
            self.player.take_damage(self.attack_damage)
            print("Boss hit player!")
        self.attack_in_progress = False  # Reset the attack flag after applying damage

    def trigger_ultimate(self):
        self.is_using_ult = True
        self.state = "ultimate"
        self.ult_frame_index = 0
        self.ult_end_time = time.time() + len(self.ult_image) * self.animation_speed
        self.last_animation_time = time.time()
        self.attack_count = 0

    def handle_ultimate(self):
        if time.time() > self.ult_end_time:
            self.is_using_ult = False
            self.state = "idle"

    def take_damage(self, amount):
        if self.is_dead:
            return

        self.hp -= amount
        print(f"Boss HP: {self.hp}/{self.max_hp}")
        if self.hp <= 0:
            self.is_dead = True
            self.state = "dying"
            self.death_index = 0
            self.last_animation_time = time.time()

    def handle_death(self):
        current_time = time.time()
        if current_time - self.last_animation_time > self.animation_speed:
            if self.death_index < len(self.death_images):
                self.image = self.death_images[self.death_index]
                if self.facing_left:
                    self.image = pygame.transform.flip(self.image, True, False)
                self.death_index += 1
                self.last_animation_time = current_time
            else:
                self.kill()
                return True
        return False

    def draw_health_bar(self, surface, camera=None):
        bar_width = 100
        bar_height = 10
        fill = (self.hp / self.max_hp) * bar_width
        if camera:
            x = self.rect.centerx - bar_width // 2 - camera.x
            y = self.rect.top - 15 - camera.y
        else:
            x = self.rect.centerx - bar_width // 2
            y = self.rect.top - 15
        pygame.draw.rect(surface, (255, 0, 0), (x, y, bar_width, bar_height))
        pygame.draw.rect(surface, (0, 255, 0), (x, y, fill, bar_height))

# Fishing
class PondArea:
    def __init__(self, center, radius_x, radius_y, day_spritesheet_path, night_spritesheet_path, rows, cols, player, detection_scale=1.5):
        self.center = center
        self.visual_radius_x = radius_x
        self.visual_radius_y = radius_y
        self.detection_radius_x = radius_x * detection_scale
        self.detection_radius_y = radius_y * detection_scale
        self.player = player
        self.fishing_sound = pygame.mixer.Sound("haojun/fishing_sound.wav")

        self.rect = pygame.Rect(
            center[0] - self.visual_radius_x,
            center[1] - self.visual_radius_y,
            self.visual_radius_x * 2,
            self.visual_radius_y * 2
        )

        # Load the day and night spritesheets
        self.day_spritesheet = pygame.image.load(day_spritesheet_path).convert_alpha()
        self.night_spritesheet = pygame.image.load(night_spritesheet_path).convert_alpha()

        # Use the day sprite sheet by default
        self.spritesheet = self.day_spritesheet
        self.rows = rows
        self.cols = cols
        self.frames = self.load_frames()
        self.current_frame = 0
        self.frame_delay = 100  # milliseconds
        self.last_update = pygame.time.get_ticks()
        self.show_animation = False
        # rewards
        self.result_display_time = 3000  # milliseconds to show result
        self.result_start_time = 0
        self.fishing_result = None  # None means nothing to show

        self.rewards = [
    {
        "id": "fish_1",
        "name": "Fish",
        "message": "You got a fish!",
        "image": pygame.image.load("images/pond/fish_1.png").convert_alpha(),
        "chance": 0.4
    },
    {
        "id": "fish_2",
        "name": "Big Fish",
        "message": "You got a fish!",
        "image": pygame.image.load("images/pond/fish_2.png").convert_alpha(),
        "chance": 0.3
    },
    {
        "id": "nothing",
        "name": "Nothing",
        "message": "You got nothing...",
        "chance": 0.2
    },
    {
        "id": "crystal",
        "name": "Crystal",
        "message": "Congratulations! You got a rare item!",
        "image": pygame.image.load("images/pond/crystal.png").convert_alpha(),
        "chance": 0.1
    }
]

        
    def load_frames(self):
        frame_width = self.spritesheet.get_width() // self.cols
        frame_height = self.spritesheet.get_height() // self.rows
        frames = []
        for row in range(self.rows):
            for col in range(self.cols):
                frame = self.spritesheet.subsurface(
                    pygame.Rect(col * frame_width, row * frame_height, frame_width, frame_height)
                )
                frames.append(frame)
        return frames

    def is_player_inside(self, player_pos):
        dx = (player_pos[0] - self.center[0]) / self.detection_radius_x
        dy = (player_pos[1] - self.center[1]) / self.detection_radius_y
        return dx * dx + dy * dy <= 1

    def update(self, player_pos, keys):
        if self.is_player_inside(player_pos) and keys[pygame.K_j]:
            self.show_animation = True
            self.current_frame = 0


        if self.show_animation:
            now = pygame.time.get_ticks()
            if now - self.last_update > self.frame_delay:
                self.current_frame += 1
                self.last_update = now
                if self.current_frame >= len(self.frames):
                    self.current_frame = 0
                    self.show_animation = False
                    self.choose_fishing_result()

    def choose_fishing_result(self):
        weights = [r["chance"] for r in self.rewards]
        result = random.choices(self.rewards, weights=weights, k=1)[0]
        self.fishing_result = result
        self.result_start_time = pygame.time.get_ticks()

        if result["id"] != "nothing":
            inventory.add_item(result["name"], 1)
            self.fishing_sound.play()
            self.player.add_exp(25) 
            self.player.stats.setdefault("fish_collected", 0)
            self.player.stats.setdefault("crystals_collected", 0)
                        
            if result["id"] in ["fish_1", "fish_2"]:
                self.player.stats["crystal_collected"] = self.player.stats.get("crystal_collected", 0) + 1
                print("Fish collected:", self.player.stats["fish_collected"])
                self.player.achievement_system.check_achievements(self.player, self.player.stats)

            elif result["id"] == "crystal":
                self.player.stats["crystal_collected"] += 1
                print("Crystal collected:", self.player.stats["crystal_collected"])
                self.player.achievement_system.check_achievements(self.player, self.player.stats)

                    
    def draw(self, screen, player_position, font, reward_font):
        if self.show_animation:
            frame = self.frames[self.current_frame]
            scaled_frame = pygame.transform.scale(frame, screen.get_size())
            screen.blit(scaled_frame, (0, 0))
        # Show "Press J to fish" if player is in detection radius
        else:
            if self.is_player_inside(player_position):
                text_surface = font.render("Press J to fish", True, (255, 255, 255))  # White text
                text_rect = text_surface.get_rect(center=(screen.get_width() // 2, screen.get_height() - 100))
                screen.blit(text_surface, text_rect)
        # Update spritesheet based on cycle 
        if self.fishing_result:
            now = pygame.time.get_ticks()
            if now - self.result_start_time < self.result_display_time:
                if "image" in self.fishing_result:
                    fishing_image = self.fishing_result["image"]
                    image = pygame.transform.rotozoom(fishing_image, 0, 1.5)
                    image_rect = image.get_rect(center=(screen.get_width() // 2, screen.get_height() // 2 - 50))
                    screen.blit(image, image_rect)

                # Draw the result message below the image
                text_surface = reward_font.render(self.fishing_result["message"], True, (255, 255, 255))
                text_rect = text_surface.get_rect(center=(screen.get_width() // 2, screen.get_height() // 2 + 70))
                screen.blit(text_surface, text_rect)
            else:
                self.fishing_result = None  # Clear result after time is up
                    
     # Update sprite sheet based on day or night
    def update_time_of_day(self, is_daytime):
        if is_daytime:
            self.spritesheet = self.day_spritesheet
        else:
            self.spritesheet = self.night_spritesheet
        self.frames = self.load_frames()  # Reload frames for the new spritesheet 
                  
class ArmorUpgradeUI:
    def __init__(self, player_instance, inventory):
        self.inventory = inventory
        self.player = player_instance
        print(f"🔍 ArmorUI INIT - Inventory has: {dict(inventory.items)}")  # Debug line
        self.visible = False
        self.armor_levels = {
            "Gold": {"wood": 40, "crystals": 4},
            "Diamond": {"wood": 60, "crystals": 6}
        }
        self.armor_type = "Iron"
        self.close_button = pygame.Rect(0, 0, 1, 1)  # Placeholder
        self.current_button_rects = []  # Initialize button rects list
        self.current_close_button = pygame.Rect(0, 0, 1, 1)  # Initialize close button
        self.font = pygame.font.SysFont(None, 24)
        self.message = ""
        self.message_timer = 0

    def handle_event(self, event):
        if not self.visible or event.type != pygame.MOUSEBUTTONDOWN or event.button != 1:
            return False

        mouse_pos = pygame.mouse.get_pos()

        # Close button
        if self.current_close_button.collidepoint(mouse_pos):
            self.visible = False
            return True

        # Handle armor upgrade buttons
        for button_rect, level in self.current_button_rects:
            if button_rect.collidepoint(mouse_pos):
                return self.attempt_upgrade(level)

        return False
        
    def toggle(self):
        self.visible = not self.visible  # Changed to toggle instead of just setting to True
        
    def draw(self, surface):
        if not self.visible:
            return

        # Darken background
        overlay = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        armor_order = ["Iron", "Gold", "Diamond"]
        current_type = self.player.armor_type if self.player.armor_type in armor_order else "Iron"
        current_index = armor_order.index(current_type)

        # Draw menu
        menu_rect = pygame.Rect(
            surface.get_width() // 2 - 200,
            surface.get_height() // 2 - 150,
            400, 300
        )
        pygame.draw.rect(surface, (100, 70, 40), menu_rect)
        pygame.draw.rect(surface, (200, 180, 100), menu_rect, 3)

        # Draw title
        title_font = pygame.font.SysFont(None, 36)
        title = title_font.render("Upgrade Armor", True, (255, 255, 255))
        surface.blit(title, (menu_rect.centerx - title.get_width() // 2, menu_rect.y + 20))

        # Draw armor options
        option_font = pygame.font.SysFont(None, 24)
        self.current_button_rects = []  # Reset button rects each draw

        y_offset = 70
        for level, costs in self.armor_levels.items():
            level_index = armor_order.index(level)
            can_upgrade = level_index == current_index + 1  # Only allow direct next upgrade

            # Skip showing levels the player already owns or has passed
            if level_index <= current_index:
                continue

            # Draw armor option
            armor_rect = pygame.Rect(
                menu_rect.centerx - 150,
                menu_rect.y + y_offset,
                300, 60
            )

            # Set color based on availability
            color = (70, 70, 120) if can_upgrade else (50, 50, 50)
            pygame.draw.rect(surface, color, armor_rect)

            # Draw armor info
            armor_text = option_font.render(f"{level} Armor", True, (255, 255, 255))
            cost_text = option_font.render(f"{costs['wood']} Wood, {costs['crystals']} Crystals", True, (255, 255, 255))

            surface.blit(armor_text, (armor_rect.x + 10, armor_rect.y + 10))
            surface.blit(cost_text, (armor_rect.x + 10, armor_rect.y + 30))

            if can_upgrade:
                self.current_button_rects.append((armor_rect, level))

            y_offset += 70

        # Draw close button
        self.current_close_button = pygame.Rect(menu_rect.right - 30, menu_rect.y + 10, 20, 20)
        pygame.draw.rect(surface, (150, 0, 0), self.current_close_button)
        x_text = self.font.render("X", True, (255, 255, 255))
        surface.blit(x_text, (self.current_close_button.centerx - x_text.get_width() // 2,
                            self.current_close_button.centery - x_text.get_height() // 2))
        
        if self.message and time.time() - self.message_timer < 2.5:
            msg_surf = self.font.render(self.message, True, (255, 255, 0))
            surface.blit(msg_surf, (surface.get_width() // 2 - msg_surf.get_width() // 2, surface.get_height() - 60))

    def attempt_upgrade(self, target_level):
        # More robust armor detection
        current_type = self.player.armor_type or "Iron"
        armor_item = f"Armor({current_type})"

        if not self.inventory.has_item(armor_item):
            self.message = f"{armor_item} not in inventory!"
            self.message_timer = time.time()
            return False

        current_type = self.player.armor_type
        armor_order = ["Iron", "Gold", "Diamond"]

        # Handle case where player has no armor equipped yet
        if current_type is None and "Iron" in armor_item:
            current_type = "Iron"

        if armor_order.index(target_level) <= armor_order.index(current_type):
            self.message = "Already upgraded!"
            self.message_timer = time.time()
            return False

        required = self.armor_levels[target_level]
        if (self.has_item_quantity("Wood", required["wood"]) and 
            self.has_item_quantity("Crystal", required["crystals"]) and 
            self.has_item_quantity(armor_item, 1)):

            self.remove_items_locally("Wood", required["wood"])
            self.remove_items_locally("Crystal", required["crystals"])
            self.remove_items_locally(armor_item, 1)

            # Add new armor - match your naming convention
            new_armor_name = f"Armor({target_level})"
            self.inventory.add_item(new_armor_name, 1)
            self.player.armor_type = target_level

            self.message = f"Upgraded to {target_level} armor!"
            self.message_timer = time.time()
            return True
        else:
            self.message = "Not enough materials!"
            self.message_timer = time.time()
            return False

    def has_item_quantity(self, item_name, quantity):
        count = 0
        for slot in self.inventory.slots:
            if slot and isinstance(slot, (tuple, list)) and slot[0] == item_name:
                count += slot[1]
                if count >= quantity:
                    return True
        return False

    def remove_items_locally(self, item_name, quantity):
        remaining = quantity
        for i, slot in enumerate(self.inventory.slots):
            if slot and isinstance(slot, (tuple, list)) and slot[0] == item_name:
                if slot[1] > remaining:
                    self.inventory.slots[i] = (slot[0], slot[1] - remaining)
                    return
                else:
                    remaining -= slot[1]
                    self.inventory.slots[i] = None
                if remaining <= 0:
                    return

def quit_game():
    print("[DEBUG] Quit triggered")
    print(f"[DEBUG] current_user = {current_user}")
    print(f"[DEBUG] player_instance.username = {player_instance.username}")
    print(f"[DEBUG] player_instance.health = {player_instance.health}")
    print(f"[DEBUG] player_instance.position = {[player_instance.position.x, player_instance.position.y]}")
    print(f"[DEBUG] player_instance.inventory = {player_instance.inventory}")
    inventory_dict = inventory.get_inventory_dict()
    user_system.save_progress(
        player_instance.username,
        player_instance.health,
        [player_instance.position.x, player_instance.position.y],
        inventory_dict,
        player_instance.level,
        player_instance.exp,
        achievement_system.achievements,
        achievement_system.shown_achievements,
        stats=player_instance.stats,
        boat_built=boat_built,  
        boss_defeated=boss_defeated       
    )
    pygame.quit()
    sys.exit()
    
main_menu = MainMenu(screen, window_size,button_image2trim,button_imagetrim)
login_page = LoginPage(screen, user_system, window_size,button_imagetrim)
register_page = RegisterPage(screen, user_system, window_size,tutorial,button_image2trim)
current_screen = "main_menu"
current_user = None
in_game = False
inventory = Inventory() 


default_achievements = {
    "First Kill": False,
    "Zombie Slayer (20 kills)": False,
    "Level 5 Achieved": False,
    "Wood Collector (10 wood)": False,
    "Fruit Picker (5 fruit)": False,
    "Lumberjack (10 wood)": False,
    "Crystal Hunter (1 crystal)": False,
    "Fisherman (10 fish)": False
}
ARMOR_PROTECTION = {
    "Armor(Iron)": 0.90,     # 10% damage reduction
    "Armor(Gold)": 0.70,     # 30% damage reduction
    "Armor(Diamond)": 0.50,  # 50% damage reduction
}
while not in_game:
    dt = clock.tick(60)  # milliseconds passed since last frame
    events = pygame.event.get()
    for event in events:
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()

    if current_screen == "main_menu":
        result = main_menu.handle_events(events)
        if result:
            current_screen = result

        main_menu.update(dt)  
        main_menu.draw()

    elif current_screen == "login_page":
        result = login_page.handle_events(events)
        if result:
            if isinstance(result, tuple) and result[0] == "game":
                current_user = result[1]
                # ✅ Initialize achievements system
                saved_achievements = user_system.users[current_user].get("achievements", {})
                # Create a new dict merging default keys with saved values, prioritizing saved values
                achievements = default_achievements.copy()
                achievements.update(saved_achievements)
                shown_achievements = set(user_system.users[current_user].get("shown_achievements", []))
                achievement_display = AchievementDisplay(font, screen)
                achievement_system = AchievementSystem(on_unlock_callback=achievement_display.show, inventory=inventory)

                # Load saved achievements and shown ones
                achievement_system.achievements = achievements
                achievement_system.shown_achievements = shown_achievements
                in_game = True  # EXIT this loop and start game
            else:
                current_screen = result
        login_page.update(dt)
        login_page.draw()

    elif current_screen == "register_page":
        result = register_page.handle_events(events)
        if result:
            if isinstance(result, tuple) and result[0] == "game":
                current_user = result[1]
                # ✅ Initialize achievements system
                saved_achievements = user_system.users[current_user].get("achievements", {})
                # Create a new dict merging default keys with saved values, prioritizing saved values
                achievements = default_achievements.copy()
                achievements.update(saved_achievements)
                achievement_display = AchievementDisplay(font, screen)
                achievement_system = AchievementSystem(on_unlock_callback=achievement_display.show, inventory=inventory)

                # Load saved achievements and shown ones
                achievement_system.achievements = achievements
                shown_achievements = user_system.users[current_user].get("shown_achievements", [])
                achievement_system.shown_achievements = shown_achievements
                in_game = True  # EXIT this loop and start game
            else:
                current_screen = result
        register_page.update(dt)
        register_page.draw()

    pygame.display.flip()

health, position, inventory_data, level, exp, boat_progress, boat_crystals, boat_built, boss_defeated = user_system.get_player_data(current_user)
saved_stats = user_system.users[current_user].get("stats", {
    "zombie_kills": 0,
    "wood_collected": 0,
    "fruit_collected": 0,
    "days_survived": 0,
})
player_instance = Player(player_position, speed, current_user, level, exp, achievement_system=achievement_system)  # Create Player instance
# Sprite groups
all_sprites = pygame.sprite.Group()
zombie_group = pygame.sprite.Group()
boss_area = pygame.Rect(240, 144, 342, 129)  # x, y, width, height
boss = Boss(399, 145, player_instance, boss_area)
all_sprites.add(boss)
game_state = "game"
spawn_delay = 3
last_spawn_time = time.time()
screen_width, screen_height = screen.get_size() 
screen_size=screen.get_size()
settings_menu = SettingsMenu(screen_size)
saved_stats = user_system.users[current_user].get("stats", None)
showing_achievements = False
achievement_page = AchievementPage(window_size, achievement_system)

if saved_stats:
    player_instance.stats = saved_stats
else:
    player_instance.stats = {
        "zombie_kills": 0,
        "wood_collected": 0,
        "fruit_collected": 0,
        "days_survived": 0,
    }
    
pond = PondArea(
    center=(1554, 585),
    radius_x=165,
    radius_y=162,
    day_spritesheet_path="images/map-sprite/new-fish-sprite.png",
    night_spritesheet_path="images/map-sprite/night-fish-sprite.png",

    rows=1,  
    cols=17,
    detection_scale=1.1,
    player=player_instance
)

# Function to spawn zombies (limit to 10)
def spawn_zombie():
    if len(zombie_group) < 10:
        # Get a random spawn position from defined zones
        x, y = get_random_spawn_position_from_zones(zombie_spawn_zones)
        
        # Create the zombie at that position
        zombie = Zombie(x, y, player_instance)
        
        # Add the zombie to the groups
        zombie_group.add(zombie)
        all_sprites.add(zombie)
        print(f"Spawned zombie at ({x}, {y})")

def get_random_spawn_position_from_zones(zones):
    zone = random.choice(zones)  # Pick a random zone
    x = random.randint(zone.left, zone.right)
    y = random.randint(zone.top, zone.bottom)
    return (x, y)

zombie_spawn_zones = [
    pygame.Rect(121, 1221, 1235, 133),  # zone 1
]
def draw_settings_menu(screen):
    screen.fill((30, 30, 30))  # dark background
    font = pygame.font.SysFont(None, 48)

    # Example buttons
    music_text = font.render("Music Volume: [Use Arrow Keys]", True, (255, 255, 255))
    quit_text = font.render("Press Q to Quit", True, (255, 255, 255))

    screen.blit(music_text, (100, 150))
    screen.blit(quit_text, (100, 250))



#Create and fill inventory
inventory.set_items(inventory_data)  # Load saved items

# Create player first
player_instance.inventory = inventory  # Assign filled inventory


# Now create inventory_menu with player
inventory_menu = InventoryMenu(inventory, window_size, player_instance)
armor_ui = ArmorUpgradeUI(player_instance, player_instance.inventory)

class CookingUI:
    def __init__(self, inventory, screen_width, screen_height):
        self.inventory = inventory
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.visible = False
        self.selected_ingredients = []
        self.dragging_item = None
        self.drag_offset = (0, 0)
        
        # Cooking area dimensions
        self.cooking_area = pygame.Rect(398, 256, 85, 80)
        
        # UI elements
        self.ingredients_panel = pygame.Rect(40, 120, 350, 250) #Ingredients box
        self.cooking_pot_panel = pygame.Rect(420, 180, 150, 150) #Pot box
        self.slot_size = 60
        self.slot_margin = 10
        self.ingredient_slots = []
        self.cooking_slots = [None, None]  # Two slots for ingredients
        self.cook_button = pygame.Rect(445, 350, 100, 40) #Cook button
        
        # Load pot image
        self.pot_image = pygame.image.load("images/house/pot.png").convert_alpha() 
        self.pot_image = pygame.transform.scale(self.pot_image, (150, 150))
        
        # Font
        self.font = pygame.font.SysFont("Times New Roman", 24)
        
        # Close button
        self.close_button_rect = pygame.Rect(40, 35, 80, 30) #Close button

        self.cooked_item = None  # Will hold (item_name, image)
        self.cooked_display_time = 0  # Timer to show the message

    def toggle(self):
        self.visible = not self.visible
        if self.visible:
            self.selected_ingredients = []
            self.update_ingredient_slots()
    
    def update_ingredient_slots(self):
        self.ingredient_slots = []
        ingredients = [item for item in self.inventory.slots 
                    if item and "ingredient" in self.inventory.item_icons[item[0]].get("categories", [])]
        
        start_x = self.ingredients_panel.x + 20
        start_y = self.ingredients_panel.y + 20
        
        for i, item in enumerate(ingredients):
            row = i // 4
            col = i % 4
            x = start_x + col * (self.slot_size + self.slot_margin)
            y = start_y + row * (self.slot_size + self.slot_margin)
            self.ingredient_slots.append({
                "rect": pygame.Rect(x, y, self.slot_size, self.slot_size),
                "item": item
            })
    
    def handle_event(self, event):
        if not self.visible:
            return False
            
        if event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1:  # Left click
                mouse_pos = pygame.mouse.get_pos()
                
                # Check if clicking on an ingredient
                for slot in self.ingredient_slots:
                    if slot["rect"].collidepoint(mouse_pos):
                        self.dragging_item = slot["item"]
                        self.drag_offset = (mouse_pos[0] - slot["rect"].x, 
                                           mouse_pos[1] - slot["rect"].y)
                        return True
                
                # Check if clicking on cook button
                if self.cook_button.collidepoint(mouse_pos):
                    self.cook()
                    return True
                
                # Check if clicking close button
                if self.close_button_rect.collidepoint(mouse_pos):
                    self.visible = False
                    return True
                
        elif event.type == pygame.MOUSEBUTTONUP:
            if event.button == 1 and self.dragging_item:
                mouse_pos = pygame.mouse.get_pos()
                
                # Check if dropping on a cooking slot
                for i, slot_rect in enumerate(self.get_cooking_slot_rects()):
                    if slot_rect.collidepoint(mouse_pos):
                        if not self.cooking_slots[i]:  # Slot is empty
                            self.cooking_slots[i] = (self.dragging_item[0], 1)
                            # Remove 1 from inventory
                            self.inventory.remove_item(
                                self.inventory.slots.index(self.dragging_item), 1)
                            self.update_ingredient_slots()
                
                self.dragging_item = None
                return True
                
        elif event.type == pygame.MOUSEMOTION and self.dragging_item:
            return True
            
        return False
    
    def get_cooking_slot_rects(self):
        # Returns rects for the two cooking slots above the pot
        pot_center = self.cooking_pot_panel.centerx
        return [
            pygame.Rect(pot_center - self.slot_size - 10, 
                       self.cooking_pot_panel.y - self.slot_size - 20,
                       self.slot_size, self.slot_size),
            pygame.Rect(pot_center + 10, 
                       self.cooking_pot_panel.y - self.slot_size - 20,
                       self.slot_size, self.slot_size)
        ]
    
    def cook(self):
        # Check if we have a valid recipe
        ingredients = [item for item in self.cooking_slots if item]
        
        for recipe_name, recipe in self.inventory.recipes.items():
            recipe_ingredients = sorted([ing[0] for ing in recipe["ingredients"]])
            current_ingredients = sorted([ing[0] for ing in ingredients])
            
            if recipe_ingredients == current_ingredients:
                # We have a match!
                result_item, result_count = recipe["result"]
                self.inventory.add_item(result_item, result_count)
                
                 # Set cooked item display
                self.cooked_item = (
                    result_item,
                    self.inventory.item_icons[result_item]["image"]
                )
                self.cooked_display_time = pygame.time.get_ticks()
                
                # Clear cooking slots
                self.cooking_slots = [None, None]
                return True
                
        # No recipe matched
        print("No matching recipe found!")
        return False
    
    def draw(self, screen):
        if not self.visible:
            return
            
        # Darken background
        overlay = pygame.Surface((self.screen_width, self.screen_height), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        screen.blit(overlay, (0, 0))
        
        # Draw ingredients panel
        pygame.draw.rect(screen, (139, 69, 19), self.ingredients_panel, border_radius=10)
        pygame.draw.rect(screen, (255, 255, 255), self.ingredients_panel, 2, border_radius=10)
        
        # Draw title
        title = self.font.render("Ingredients", True, (255, 255, 255))
        screen.blit(title, (self.ingredients_panel.x + 10, self.ingredients_panel.y - 35))
        
        # Draw ingredient slots
        for slot in self.ingredient_slots:
            pygame.draw.rect(screen, (200, 200, 200), slot["rect"])
            item_name, item_count = slot["item"]
            icon = self.inventory.item_icons[item_name]["image"]
            icon = pygame.transform.scale(icon, (self.slot_size - 10, self.slot_size - 10))
            screen.blit(icon, (slot["rect"].x + 5, slot["rect"].y + 5))
            
            count_text = self.font.render(f"x{item_count}", True, (0, 0, 0))
            screen.blit(count_text, (slot["rect"].right - 25, slot["rect"].bottom - 20))
        
        # Draw cooking panel
        pygame.draw.rect(screen, (100, 100, 100), self.cooking_pot_panel, border_radius=10)
        pygame.draw.rect(screen, (255, 255, 255), self.cooking_pot_panel, 2, border_radius=10)
        
        # Draw pot image
        screen.blit(self.pot_image, 
                   (self.cooking_pot_panel.centerx - self.pot_image.get_width()//2,
                    self.cooking_pot_panel.centery - self.pot_image.get_height()//2))
        
        # Draw cooking slots above pot
        slot_rects = self.get_cooking_slot_rects()
        for i, rect in enumerate(slot_rects):
            pygame.draw.rect(screen, (200, 200, 200), rect)
            if self.cooking_slots[i]:
                item_name = self.cooking_slots[i][0]
                icon = self.inventory.item_icons[item_name]["image"]
                icon = pygame.transform.scale(icon, (self.slot_size - 10, self.slot_size - 10))
                screen.blit(icon, (rect.x + 5, rect.y + 5))
        
        # Draw cook button
        pygame.draw.rect(screen, (50, 150, 50), self.cook_button, border_radius=5)
        cook_text = self.font.render("Cook", True, (255, 255, 255))
        screen.blit(cook_text, (self.cook_button.centerx - cook_text.get_width()//2,
                               self.cook_button.centery - cook_text.get_height()//2))
        
        # Draw close button
        pygame.draw.rect(screen, (200, 50, 50), self.close_button_rect, border_radius=5)
        close_text = self.font.render("Close", True, (255, 255, 255))
        screen.blit(close_text, (self.close_button_rect.centerx - close_text.get_width()//2,
                                self.close_button_rect.centery - close_text.get_height()//2))
        
        # Draw dragging item if any
        if self.dragging_item:
            mouse_pos = pygame.mouse.get_pos()
            item_name = self.dragging_item[0]
            icon = self.inventory.item_icons[item_name]["image"]
            icon = pygame.transform.scale(icon, (self.slot_size - 10, self.slot_size - 10))
            screen.blit(icon, (mouse_pos[0] - self.drag_offset[0] + 5, 
                             mouse_pos[1] - self.drag_offset[1] + 5))
    
        # Display cooked item result
        if self.cooked_item:
            elapsed = pygame.time.get_ticks() - self.cooked_display_time
            if elapsed < 3000:  # Show for 3 seconds
                cooked_name, cooked_image = self.cooked_item

                # Setup box dimensions
                box_width, box_height = 200, 130
                box_x = self.screen_width // 2 - box_width // 2
                box_y = self.screen_height // 2 - box_height // 2
                box_rect = pygame.Rect(box_x, box_y, box_width, box_height)

                # Draw white background and gray border
                pygame.draw.rect(screen, (255, 255, 255), box_rect)        # White background
                pygame.draw.rect(screen, (120, 120, 120), box_rect, 4)     # Grey border

                # Draw image
                image = pygame.transform.scale(cooked_image, (100, 100))
                screen.blit(image, (box_x + box_width // 2 - 40, box_y + 10))

                # Draw text
                text = self.font.render(f"You have cooked {cooked_name}!", True, WHITE)
                screen.blit(text, (
                    box_x + box_width // 2 - text.get_width() // 2,
                    box_y + 150
                ))
            else:
                self.cooked_item = None


    def open(self):
        self.visible = True
        self.selected_ingredients = []
        self.update_ingredient_slots()

    def close(self):
        self.visible = False

# Cooking
cooking_ui = CookingUI(inventory, screen.get_width(), screen.get_height())

# Recipe book
class RecipeBookUI:
    def __init__(self, image_path, close_button_rect, font):
        self.image = pygame.image.load("images/house/recipe.png").convert_alpha()
        self.visible = False
        self.font = font
        self.close_button = pygame.Rect(0, 0, 1, 1)
        
        # Position and size for the UI window
        self.window_rect = pygame.Rect(100, 100, self.image.get_width() + 40, self.image.get_height() + 80)
        
        # Close button rect (you can customize position/size)
        self.close_button_rect = pygame.Rect(close_button_rect)
        
    def open(self):
        self.visible = True
        
    def close(self):
        self.visible = False
        
    def handle_event(self, event):
        if not self.visible:
            return
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.close_button_rect.collidepoint(event.pos):
                self.close()
    
    def draw(self, surface):
        if not self.visible:
            return
        
        # Draw the image centered inside the window with some padding
        image_pos = (self.window_rect.x - 100 , self.window_rect.y - 70)
        surface.blit(self.image, image_pos)
        
        #close button
        self.close_button = pygame.Rect(560, 90, 25, 30)
        pygame.draw.rect(surface, (150, 0, 0), self.close_button)
        x_text = self.font.render("X", True, (255, 255, 255))
        surface.blit(x_text, (self.close_button.centerx - x_text.get_width() // 2,
                            self.close_button.centery - x_text.get_height() // 2))


class CraftingTable:
    def __init__(self, position, size):
        x, y = position if isinstance(position, (list, tuple)) and len(position) == 2 else (0, 0)
        w, h = size if isinstance(size, (list, tuple)) and len(size) == 2 else (100, 100)
        self.rect = pygame.Rect(x, y, w, h)
        self.visible = False
        self.boat_built = False
        self.armor_upgraded = False
        self.boat_icon = pygame.image.load("images/craft-icon/build.png").convert_alpha()
        self.armor_icon = pygame.image.load("images/craft-icon/upgrade.png").convert_alpha()     
        
    def interact(self):
        self.visible = True
       
    def draw(self, surface):
        if self.visible:
            # Darken background
            overlay = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 180))
            surface.blit(overlay, (0, 0))

            # Draw crafting menu background
            menu_rect = pygame.Rect(
                surface.get_width()//2 - 150,
                surface.get_height()//2 - 150,
                300, 300
            )
            pygame.draw.rect(surface, (100, 70, 40), menu_rect)
            pygame.draw.rect(surface, (200, 180, 100), menu_rect, 3)

            menu_rect = pygame.Rect(
            surface.get_width()//2 - 150,
            surface.get_height()//2 - 150,
            300, 300
            )
            pygame.draw.rect(surface, (100, 70, 40), menu_rect)
            pygame.draw.rect(surface, (200, 180, 100), menu_rect, 3)

            # --- Circular Close Button (X) ---
            close_center = (menu_rect.right - 25, menu_rect.top + 25)  # Circle center
            close_radius = 15

            # Draw circle (background and border)
            pygame.draw.circle(surface, (150, 0, 0), close_center, close_radius)        # Red circle
            pygame.draw.circle(surface, (255, 255, 255), close_center, close_radius, 2) # White border

            # Draw "X" text in center
            x_font = pygame.font.SysFont(None, 28)
            x_text = x_font.render("X", True, (255, 255, 255))
            x_text_rect = x_text.get_rect(center=close_center)
            surface.blit(x_text, x_text_rect)

            # Draw title
            title_font = pygame.font.SysFont(None, 40)
            title = title_font.render("Crafting Table", True, (255, 255, 255))
            surface.blit(title, (menu_rect.centerx - title.get_width()//2, menu_rect.y + 30))

            # Font for options
            option_font = pygame.font.SysFont(None, 28)

            # --- Boat Option ---
            boat_rect = pygame.Rect(menu_rect.centerx - 105, menu_rect.centery - 60, 220, 80)
            pygame.draw.rect(surface, (70, 50, 30), boat_rect)
            boat_text = option_font.render("Build Boat", True, (255, 255, 255))
            
            # Draw boat icon
            if hasattr(self, 'boat_icon'):
                icon = pygame.transform.scale(self.boat_icon, (50, 50))
                icon_x = boat_rect.x + 10
                icon_y = boat_rect.centery - icon.get_height() // 2
                surface.blit(icon, (icon_x, icon_y))

                # Text beside icon
                surface.blit(boat_text, (icon_x + 60, boat_rect.centery - 10))
            else:
                surface.blit(boat_text, (boat_rect.centerx - boat_text.get_width()//2, boat_rect.centery - 10))

            # --- Armor Option ---
            armor_rect = pygame.Rect(menu_rect.centerx - 105, menu_rect.centery + 40, 220, 80)
            pygame.draw.rect(surface, (100, 100, 100), armor_rect)
            armor_text = option_font.render("Upgrade Armor", True, (255, 255, 255))

            # Draw armor icon
            if hasattr(self, 'armor_icon'):
                icon = pygame.transform.scale(self.armor_icon, (50, 50))
                icon_x = armor_rect.x + 10
                icon_y = armor_rect.centery - icon.get_height() // 2
                surface.blit(icon, (icon_x, icon_y))

                # Text beside icon
                surface.blit(armor_text, (icon_x + 50, armor_rect.centery - 10))
            else:
                surface.blit(armor_text, (armor_rect.centerx - armor_text.get_width()//2, armor_rect.centery - 10))

            return boat_rect, armor_rect
        
print("game_state is:", game_state, type(game_state))

class BoatBuildingUI:
    def __init__(self, inventory, player, boat_progress=0, boat_crystals=0):
        self.inventory = inventory
        self.visible = False
        self.player = player
        self.boat_progress = boat_progress  # wood contributed
        self.boat_crystals = boat_crystals
        self.frames = self.load_sprite_frames('images/map-sprite/boat-sprite.png', 25)
        self.frame_width = self.frames[0].get_width()
        self.frame_height = self.frames[0].get_height()
        self.font = pygame.font.SysFont(None, 24)
        self.close_button = pygame.Rect(0, 0, 1, 1)
        self.add_button = pygame.Rect(0, 0, 1, 1)
        self.max_wood = 50
        self.max_crystals = 5
        self.message = ""
        self.boat_complete = False

    def load_sprite_frames(self, path, num_frames):
        sheet = pygame.image.load(path).convert_alpha()
        frame_width = sheet.get_width() // num_frames
        return [sheet.subsurface(pygame.Rect(i * frame_width, 0, frame_width, sheet.get_height()))
                for i in range(num_frames)]

    def toggle(self):
        self.visible = not self.visible

    def handle_event(self, event):
        if not self.visible:
            return False
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.close_button.collidepoint(event.pos):
                self.toggle()
                return True
            elif self.add_button.collidepoint(event.pos):
                self.try_add_materials()
                return True
        return False

    def draw(self, surface):
        if not self.visible:
            return

        overlay = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))

        menu_rect = pygame.Rect(surface.get_width() // 2 - 200, surface.get_height() // 2 - 150, 400, 300)
        pygame.draw.rect(surface, (100, 70, 40), menu_rect)
        pygame.draw.rect(surface, (200, 180, 100), menu_rect, 3)

        title = pygame.font.SysFont(None, 36).render("Build Boat", True, (255, 255, 255))
        surface.blit(title, (menu_rect.centerx - title.get_width() // 2, menu_rect.y + 20))

        level = player.level
        surface.blit(self.font.render(f"Level: {level}", True, (255, 255, 255)), (menu_rect.x + 50, menu_rect.y + 70))

        surface.blit(self.font.render(f"Wood: {self.boat_progress}/50", True, (255, 255, 255)), (menu_rect.x + 50, menu_rect.y + 100))
        surface.blit(self.font.render(f"Crystals: {self.boat_crystals}/5", True, (255, 255, 255)), (menu_rect.x + 200, menu_rect.y + 100))

        if level < 20:
            warning_box = pygame.Rect(menu_rect.centerx - 140, menu_rect.y + 140, 280, 30)
            pygame.draw.rect(surface, (80, 0, 0), warning_box)
            pygame.draw.rect(surface, (255, 0, 0), warning_box, 2)
            warning_text = self.font.render("Build Boat unlocks at level 20!", True, (255, 50, 50))
            surface.blit(warning_text, (warning_box.centerx - warning_text.get_width() // 2,
                                        warning_box.centery - warning_text.get_height() // 2))
            self.add_button = pygame.Rect(0, 0, 0, 0)
            
        elif self.boat_progress < self.max_wood or self.boat_crystals < self.max_crystals:
            self.add_button = pygame.Rect(menu_rect.centerx - 100, menu_rect.y + 140, 200, 30)
            pygame.draw.rect(surface, (50, 150, 50), self.add_button)
            add_text = self.font.render("Add Materials", True, (255, 255, 255))
            surface.blit(add_text, (self.add_button.centerx - add_text.get_width() // 2,
                                    self.add_button.centery - add_text.get_height() // 2))
        else:
            done_text = self.font.render("Boat fully constructed!", True, (255, 255, 0))
            self.boat_complete = True
            surface.blit(done_text, (menu_rect.centerx - done_text.get_width() // 2, menu_rect.y + 145))

        # Show boat sprite only if wood/crystals have been added
        if self.boat_progress > 0 or self.boat_crystals > 0:
            frame_index = min((self.boat_progress + self.boat_crystals * 10) // 2, len(self.frames) - 1)
            sprite = self.frames[frame_index]
            sprite_pos = (menu_rect.centerx - self.frame_width // 2, menu_rect.y + 100)
            surface.blit(sprite, sprite_pos)

        if self.message:
            msg = self.font.render(self.message, True, (255, 255, 100))
            surface.blit(msg, (menu_rect.centerx - msg.get_width() // 2, menu_rect.y + 270))

        self.close_button = pygame.Rect(menu_rect.right - 30, menu_rect.y + 10, 20, 20)
        pygame.draw.rect(surface, (150, 0, 0), self.close_button)
        x_text = self.font.render("X", True, (255, 255, 255))
        surface.blit(x_text, (self.close_button.centerx - x_text.get_width() // 2,
                              self.close_button.centery - x_text.get_height() // 2))

    def try_add_materials(self):
        self.message = ""
        if self.player.level < 20:
            self.message = "Build Boat unlocks at level 20!"
            return

        elif self.boat_progress >= self.max_wood and self.boat_crystals >= self.max_crystals:
            self.message = "All materials added!"
            self.save_progress()
            return

        wood_count = self.inventory.get_item_count("Wood")
        crystal_count = self.inventory.get_item_count("Crystal")

        if wood_count == 0 and crystal_count == 0:
            self.message = "Not enough materials!"
            return

        added = False
        if self.boat_progress< self.max_wood and wood_count > 0:
            if self.inventory.remove_items("Wood", 1):
                self.boat_progress += 1
                added = True

        if self.boat_crystals < self.max_crystals and crystal_count > 0:
            if self.inventory.remove_items("Crystal", 1):
                self.boat_crystals += 1
                added = True

        if not added:
            self.message = "Not enough materials!"
        else:
            self.message = "Materials added!"

    def save_progress(self, filename="boat_progress.json"):
        data = {
            "boat_progress": self.boat_progress,
            "boat_crystals": self.boat_crystals
        }
        with open(filename, "w") as f:
            json.dump(data, f)

    def load_progress(self, filename="boat_progress.json"):
        if os.path.exists(filename):
            with open(filename, "r") as f:
                data = json.load(f)
                self.boat_progress = data.get("boat_progress", 0)
                self.boat_crystals = data.get("boat_crystals", 0)
                
class ArmorUpgradeUI:
    def __init__(self, inventory, player):
        self.inventory = inventory
        self.player = player
        self.visible = False
        self.armor_levels = {
            "Iron": {"wood": 20, "crystals": 2},
            "Gold": {"wood": 40, "crystals": 4},
            "Diamond": {"wood": 60, "crystals": 6}
        }
        self.armor_type = "iron"
        self.close_button = pygame.Rect(0, 0, 1, 1)  # Placeholder, updated in draw()
        self.add_button = pygame.Rect(0, 0, 1, 1)
        self.font = pygame.font.SysFont(None, 24)
        
    def handle_event(self, event):
        if not self.visible:
            return False
        
        
    def toggle(self):
        self.visible = True
        
    def draw(self, surface):
        if not self.visible:
            return
            
        # Darken background
        overlay = pygame.Surface(surface.get_size(), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        armor_order = ["Iron", "Gold", "Diamond"]
        current_type = self.player.armor_type if self.player.armor_type in armor_order else "Iron"
        current_index = armor_order.index(current_type)

        for level, costs in self.armor_levels.items():
            level_index = armor_order.index(level)
            can_upgrade = level_index > current_index
        
        # Draw menu
        menu_rect = pygame.Rect(
            surface.get_width()//2 - 200,
            surface.get_height()//2 - 150,
            400, 300
        )
        pygame.draw.rect(surface, (100, 70, 40), menu_rect)
        pygame.draw.rect(surface, (200, 180, 100), menu_rect, 3)
        
        # Draw title
        title_font = pygame.font.SysFont(None, 36)
        title = title_font.render("Upgrade Armor", True, (255, 255, 255))
        surface.blit(title, (menu_rect.centerx - title.get_width()//2, menu_rect.y + 20))
        
        # Draw armor options
        option_font = pygame.font.SysFont(None, 24)
        button_rects = []
        
        y_offset = 70
        for level, costs in self.armor_levels.items():
            # Check if player already has this armor or higher
            current_armor = self.player.armor_type
            can_upgrade = True
            
            # Draw armor option
            armor_rect = pygame.Rect(
                menu_rect.centerx - 150,
                menu_rect.y + y_offset,
                300, 60
            )
            
            # Set color based on availability
            if current_armor == level:
                color = (100, 200, 100)  # Already owned
            elif can_upgrade:
                color = (70, 70, 120)  # Available
            else:
                color = (50, 50, 50)  # Not available
                
            pygame.draw.rect(surface, color, armor_rect)
            
            # Draw armor info
            armor_text = option_font.render(f"{level} Armor", True, (255, 255, 255))
            cost_text = option_font.render(f"{costs['wood']} Wood, {costs['crystals']} Crystals", True, (255, 255, 255))
            
            surface.blit(armor_text, (armor_rect.x + 10, armor_rect.y + 10))
            surface.blit(cost_text, (armor_rect.x + 10, armor_rect.y + 30))
            
            button_rects.append((armor_rect, level))
            y_offset += 70
            
            # Update close button rect
            self.close_button = pygame.Rect(menu_rect.right - 30, menu_rect.y + 10, 20, 20)
            pygame.draw.rect(surface, (150, 0, 0), self.close_button)
            x_text = self.font.render("X", True, (255, 255, 255))
            surface.blit(x_text, (self.close_button.centerx - x_text.get_width() // 2,
                                self.close_button.centery - x_text.get_height() // 2))
        
        return button_rects, self.close_button

     
player=player_instance
boat_ui = BoatBuildingUI(player.inventory, player, boat_progress=0, boat_crystals=0)
recipe_ui = RecipeBookUI("images/house/recipe.png", (600, 120, 30, 30), font)


# Main loop
running = True
crafting_ui = CraftingTable(game_state, position)
while running:
    dt = clock.tick(60) / 1000
    if time_counter >= cycle_duration:
        time_counter = 0
    current_time = pygame.time.get_ticks() / 1000
    events = pygame.event.get()
    for event in events:
        tutorial.handle_event(event)
        # ✅ Handle armor UI button click
        if armor_ui.visible:
            armor_ui.handle_event(event)
        if event.type == pygame.QUIT:
            # Save progress before exiting
            inventory_dict = inventory.get_inventory_dict()
            progress_data = {
                "position": [player_instance.position.x, player_instance.position.y],
                "health": player_instance.health,
                "inventory":inventory_dict,
                "level": player_instance.level,
                "exp":player_instance.exp,
                "achievements": achievement_system.achievements,
                "shown_achievements": list(achievement_system.shown_achievements),
                "stats": player_instance.stats
                
            }
            # Save the progress
            print(f"[SAVE] Health being saved: {player_instance.health}")
            user_system.save_progress(
                    player_instance.username,
                    player_instance.health,
                    [player_instance.position.x, player_instance.position.y],
                    inventory_dict,
                    player_instance.level,
                    player_instance.exp,
                    achievement_system.achievements,
                    achievement_system.shown_achievements,
                    stats=player_instance.stats
                )
            running = False        
            # Event handling for achievements screen:
        if game_state == "achievements":
            if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                game_state = "settings"
                achievement_page.visible = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                if game_state == "game":
                    game_state = "settings"
                    settings_menu.visible = True
                elif game_state == "settings":
                    game_state = "game"
                    settings_menu.visible = False

            elif event.key == pygame.K_EQUALS:
                minimap_zoom_factor = min(4.0, minimap_zoom_factor + 0.1)
            
            elif event.key == pygame.K_MINUS:
                minimap_zoom_factor = max(0.5, minimap_zoom_factor - 0.1)
            
            elif event.key == pygame.K_TAB:
                player_instance.switch_weapon(event.key)
            
            elif event.key == pygame.K_f:  # F key to toggle fullscreen
                is_fullscreen = not is_fullscreen
                if is_fullscreen:
                    screen = pygame.display.set_mode((0, 0), pygame.FULLSCREEN)
                    character_scale = fullscreen_scale  # Increase size
                    settings_menu.create_buttons(screen.get_size())
                else:
                    screen = pygame.display.set_mode(window_size)
                    character_scale = 1.0  # Normal sizee
                    settings_menu.create_buttons(screen.get_size())
                overlay = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
                inventory_menu.update_layout(screen.get_size())
                tutorial.update_layout(screen.get_size())
            
                achievement_page.update_layout(screen.get_size())
            elif event.key == pygame.K_b:
                inventory_menu.toggle()

            elif event.key == pygame.K_t:
                print("T pressed")
                tutorial.toggle()

            if tutorial.show:
                if event.key == pygame.K_RIGHT:
                    tutorial.next_page()
                elif event.key == pygame.K_LEFT:
                    tutorial.prev_page()

        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_SPACE:
                player_instance.attacking = True
            
    
        # In the main game loop's event handling section (where other events are handled):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:  # Left mouse button
            if tutorial.help_icon_rect.collidepoint(event.pos):
                tutorial.toggle()
            mouse_pos = pygame.mouse.get_pos()
            # Convert mouse position to world coordinates for cooking area check
            world_mouse_x = mouse_pos[0] * (camera.width / screen.get_width()) + camera.x
            world_mouse_y = mouse_pos[1] * (camera.height / screen.get_height()) + camera.y
                
            # Existing inventory menu click handling
            if inventory_menu.visible:
                inventory_menu.handle_click(event.pos)

        # Handle settings menu events
        if game_state == "settings":
            result = settings_menu.handle_events(event)
            if result == "quit":
                inventory_dict = inventory.get_inventory_dict()
                progress_data = {
                    "position": [player_instance.position.x, player_instance.position.y],
                    "health": player_instance.health,
                    "inventory":inventory_dict
                }
                # Save the progress
                user_system.save_progress(
                        player_instance.username,
                        player_instance.health,
                        [player_instance.position.x, player_instance.position.y],
                        inventory_dict,
                        player_instance.level,
                        player_instance.exp,
                        achievement_system.achievements,
                        achievement_system.shown_achievements,
                        stats=player_instance.stats
                    )
                running = False
            elif result == "back":
                game_state = "game"
                settings_menu.visible = False
            elif result == "achievements":  # 🆕 Add this
                game_state = "achievements"  # ⬅ Change the state to show achievements
                         
    # ========== GAME LOGIC ONLY WHEN IN "GAME" STATE ==========
    if game_state == "game":
        keys = pygame.key.get_pressed()
        new_position, current_sprite, hairclip_sprite, zombieskin_sprite = player_instance.move(keys, dt)
        move_distance = speed * dt * 60

        current_time = time.time()
        if current_time - last_spawn_time >= spawn_delay and len(zombie_group) < 10:
            spawn_zombie()
            last_spawn_time = current_time

        zombie_group.update()
        boss.update()
        if boss.is_dead and boat_ui.boat_complete and not show_boat:
            print("boat built")
            print("Boss dead")
            show_boat = True
            if show_boat:
                print("Show boat")
                screen.blit(boat_image, (boat_rect.x - camera.x, boat_rect.y - camera.y))

            # Check if player is near boat
            if player.rect.colliderect(boat_rect.inflate(100, 100)) and show_boat: 
                print("INSIDE BOAT AREA")
                show_press_j_message = True
                if keys[pygame.K_j]:
                    game_ended = True
                    end_sprite_index = 0
                    end_sprite_timer = time.time()
            else:
                show_press_j_message = False

            if show_press_j_message:
                msg = font.render("Press J to use boat", True, (255, 255, 255))
                text_rect = msg.get_rect(center=(screen.get_width() // 2, screen.get_height() - 100))
                screen.blit(msg, text_rect)
                
        # GAME ENDING        
        if game_ended:
            current_time = time.time()
            if current_time - end_sprite_timer > end_sprite_speed and end_sprite_index < len(end_game_frames):
                end_sprite_index += 1
                end_sprite_timer = current_time

            if end_sprite_index >= len(end_game_frames):
                end_sprite_index = len(end_game_frames) - 1  # freeze on last frame

            screen.blit(end_game_frames[end_sprite_index], (player.rect.centerx - 200, player.rect.centery - 200))  # adjust position

            end_text = font.render("Game Ended", True, (255, 255, 255))
            screen.blit(end_text, (screen.get_width() // 2 - end_text.get_width() // 2, 50))
        
        # Movement with restriction zone logic
        proposed_position = player_instance.position.copy()
        for direction in ["w", "s", "a", "d"]:
            if keys[getattr(pygame, f"K_{direction}")]:
                test_pos = proposed_position.copy()
                if direction == "w": test_pos.y -= move_distance
                if direction == "s": test_pos.y += move_distance
                if direction == "a": test_pos.x -= move_distance
                if direction == "d": test_pos.x += move_distance
                test_rect = pygame.Rect(test_pos.x - 20, test_pos.y - 20, 40, 40)
                if not is_in_restricted_zone(test_rect.center, restricted_zones):
                    if direction == "w": proposed_position.y -= move_distance; player_instance.direction = "up"
                    if direction == "s": proposed_position.y += move_distance; player_instance.direction = "down"
                    if direction == "a": proposed_position.x -= move_distance; player_instance.direction = "left"
                    if direction == "d": proposed_position.x += move_distance; player_instance.direction = "right"


    achievement_system.check_achievements(player_instance, player_instance.stats)

    proposed_position.x = max(0, min(proposed_position.x, map_image.get_width()))
    proposed_position.y = max(0, min(proposed_position.y, map_image.get_height()))

    player_instance.position = proposed_position
    player_position = proposed_position

    attack_sprite = player_instance.attack(trees,zombie_group)

    camera.center = player_position
    camera.clamp_ip(map_image.get_rect())

    zoom_surface.fill((0, 0, 0))
    zoom_surface.blit(map_image, (0, 0), camera)

    

    for tree in trees:
        tree.update(current_time)
        tree.draw(zoom_surface, camera)

    for tree in trees_2:
        tree.update(current_time)
        tree.draw(zoom_surface, camera)

    for zombie in zombie_group:
        zoom_surface.blit(zombie.image, zombie.rect.move(-camera.x, -camera.y))
        zombie.draw_health_bar(zoom_surface, camera)

    keys = pygame.key.get_pressed()
    pond.update(player_instance.rect.center, keys)
   
        # Boss draw
    if boss.alive():  # Check if boss hasn't been killed
        boss_rect_on_screen = boss.rect.move(-camera.x, -camera.y)
        zoom_surface.blit(boss.image, boss_rect_on_screen)
        if not boss.is_dead:
            boss.draw_health_bar(zoom_surface, camera)

        # Final game drawing
    zoomed_view = pygame.transform.scale(zoom_surface, screen.get_size())
    screen.blit(zoomed_view, (0, 0))

    # Draw scaled character
    sprite_to_draw = attack_sprite if attack_sprite else current_sprite
    scaled_sprite = scale_sprite(sprite_to_draw, character_scale)
    sprite_x = screen.get_width() // 2 - scaled_sprite.get_width() // 2
    sprite_y = screen.get_height() // 2 - scaled_sprite.get_height() // 2
    screen.blit(scaled_sprite, (sprite_x, sprite_y))
    player_instance.draw_health_bar(screen)#player hp bar
    player_instance.draw_health_bar(screen)
    player_instance.draw_exp_bar(screen)

    if zombieskin_sprite:
        scaled_zombieskin = scale_sprite(zombieskin_sprite, character_scale)
        screen.blit(scaled_zombieskin, (sprite_x, sprite_y))

    if hairclip_sprite:
        scaled_hairclip = scale_sprite(hairclip_sprite, character_scale)
        screen.blit(scaled_hairclip, (sprite_x, sprite_y))


    # Minimap
    minimap_surface = pygame.Surface((minimap_radius * 2, minimap_radius * 2), pygame.SRCALPHA)
    mini_camera_size = minimap_radius * 2 / minimap_zoom_factor
    mini_camera = pygame.Rect(0, 0, mini_camera_size, mini_camera_size)
    mini_camera.center = player_position
    mini_camera.clamp_ip(map_image.get_rect())
    mini_view = map_image.subsurface(mini_camera).copy()
    scaled_mini_view = pygame.transform.scale(mini_view, (minimap_radius * 2, minimap_radius * 2))
    minimap_surface.blit(scaled_mini_view, (0, 0))
    masked_minimap = minimap_surface.copy()
    masked_minimap.blit(minimap_mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
    pygame.draw.circle(masked_minimap, player_minimap_color, (minimap_radius, minimap_radius), 3)
    pygame.draw.circle(masked_minimap, minimap_border_color, (minimap_radius, minimap_radius), minimap_radius, minimap_border_width)
    screen.blit(masked_minimap, (minimap_pos[0] - minimap_radius, minimap_pos[1] - minimap_radius))
    relative_x = (player_position.x - mini_camera.left) / mini_camera.width * (minimap_radius * 2)
    relative_y = (player_position.y - mini_camera.top) / mini_camera.height * (minimap_radius * 2)
    
    # Day-night cycle (NEW day 66% night 33%)    
    cycle_duration = 60  # full cycle in seconds
    day_duration = cycle_duration * 0.66  # ~39.6s
    night_duration = cycle_duration * 0.34  # ~20.4s

    time_counter += dt
    cycle_time = time_counter % cycle_duration
    if cycle_time < day_duration:
        alpha = 0  # Full daylight (no fade)
        pond.update_time_of_day(is_daytime=True)  # Set to day for fishing sprite
    else:
        # Night fade-in (0 to 180 alpha) during night duration
        night_progress = (cycle_time - day_duration) / night_duration
        alpha = int(night_progress * 180)
        pond.update_time_of_day(is_daytime=False)  # Set to night for fishing sprite
    
    offset = pygame.math.Vector2(0, 0)

    overlay.fill((0, 0, 50, alpha))
    screen.blit(overlay, (0, 0))

    pos_text = f"X: {int(player_position.x)}  Y: {int(player_position.y)}"
    text_surface = font.render(pos_text, True, (255, 255, 255))
    screen.blit(text_surface, (10, screen.get_height() - 30))

    icon = player_instance.weapon_icons[player_instance.current_weapon]
    icon_scaled = pygame.transform.scale(icon, (60, 60))

    # Draw a box (bottom-left for example)
    weapon_box = pygame.Rect(screen.get_width() - 100, screen.get_height() - 100, 80, 80)
    pygame.draw.rect(screen, (30, 30, 30), weapon_box)  # Dark box
    pygame.draw.rect(screen, (255, 255, 255), weapon_box, 2)  # White border
    screen.blit(icon_scaled, (weapon_box.x + 10, weapon_box.y + 10))
    
    
    #Draw pond
    pond.draw(screen, player_position, font, reward_font)
    inventory.draw(screen)
    if not pond.show_animation:
        tutorial.update(dt)
        tutorial.draw(screen)
        
   
    # ========== DRAW SETTINGS MENU WHEN ACTIVE ==========
    if game_state == "settings":
        screen.fill((10, 10, 10))  # Optional: dim background
        settings_menu.draw(screen)

    if inventory_menu.visible:
        inventory_menu.draw(screen)
    if show_house_prompt and not in_house:
        text = font.render("Press J to enter house", True, (255, 255, 255))
        text_rect = text.get_rect(center=(screen.get_width()//2, screen.get_height()-10))
        screen.blit(text, text_rect)
    
    if not in_house:  # Only process these if player is outside
    # Check if player is in house area
        player_rect = pygame.Rect(player_position.x-20, player_position.y-20, 40, 40)
        show_house_prompt = False
    for zone in house_area:
        if zone["type"] == "rect" and zone["rect"].colliderect(player_rect):
            show_house_prompt = True
            if keys[pygame.K_j]:
                in_house = True
                # Pause game state
                paused_world_state = {
                    "player_pos": player_position.copy(),
                    "time_counter": time_counter,
                    # Add any other state you want to preserve
                }
            break
              
    if in_house:
        screen_width, screen_height = screen.get_size()
        scaled_house = pygame.transform.scale(house_image, (screen_width, screen_height))
        screen.blit(scaled_house, (0, 0))

        # Get mouse position and events once
        mouse_pos = pygame.mouse.get_pos()
        events = pygame.event.get()
        mouse_clicked = False

        for event in events:
            if event.type == pygame.MOUSEBUTTONDOWN:
                mouse_clicked = True

        # If UI is visible, pass events to it
        if cooking_ui.visible:
            for event in events:
                cooking_ui.handle_event(event)

        # Open UI only on clicking pot and if not already open
        if mouse_clicked and cooking_ui.cooking_area.collidepoint(mouse_pos) and not cooking_ui.visible:
            cooking_ui.open()

        # Always draw UI if it's visible
        if cooking_ui.visible:
            cooking_ui.draw(screen)
                    
        # UI elements in house
        button_width, button_height = 120, 40

        # Top-center anchor
        button_x = screen_width // 2 - button_width // 2
        button_y = 36  
        
        # Draw the button
        button_rect = pygame.Rect(button_x, button_y, button_width, button_height)
        pygame.draw.rect(screen, (200, 200, 200), (button_x, button_y, button_width, button_height))

        # Render and center the text
        button_text = font.render("Exit House", True, (0, 0, 0))
        text_rect = button_text.get_rect(center=(button_x + button_width // 2, button_y + button_height // 2))
        screen.blit(button_text, text_rect)
        mouse_x, mouse_y = mouse_pos

        if button_rect.collidepoint(mouse_x, mouse_y) and mouse_clicked:
            in_house = False
            player_position = paused_world_state["player_pos"]
            time_counter = paused_world_state["time_counter"]
        
        recipe_book_rect = pygame.Rect(161, 125, 53, 18)
        if recipe_book_rect.collidepoint(mouse_x, mouse_y) and mouse_clicked and not recipe_ui.visible:
            print("open recipe book")
            recipe_ui.open()
        if recipe_ui.open:    
            recipe_ui.draw(screen)
            if mouse_clicked: 
                if recipe_ui.close_button.collidepoint(mouse_pos):
                    recipe_ui.visible = False  # Close the boat UI
           
        #  Paper Zone (clickable wall area)
        paper_zone_rect = pygame.Rect(25, 95, 81, 50)  # Adjust coords and size
        if paper_zone_rect.collidepoint(mouse_x, mouse_y) and mouse_clicked and not paper_visible:
            paper_visible = True

        #  Paper UI
        if paper_visible:
            scaled_paper = pygame.transform.scale(paper_image, (screen_width, screen_height))
            screen.blit(scaled_paper, (0, 0))

            close_width, close_height = 100, 40
            close_x = screen_width // 2 - close_width // 2
            close_y = 400
            close_button_rect = pygame.Rect(260, 400, 100, 25)
            pygame.draw.rect(screen, (220, 220, 220), (close_x, close_y, close_width, close_height))
            close_text = font.render("Close", True, (0, 0, 0))
            close_text_rect = close_text.get_rect(center=(close_x + close_width // 2, close_y + close_height // 2))
            screen.blit(close_text, close_text_rect)

            if close_button_rect.collidepoint(mouse_x, mouse_y) and mouse_clicked:
                paper_visible = False
                
        crafting_ui_area = pygame.Rect(122, 232, 90, 86)
        boat_rect = pygame.Rect(205, 180, 220, 80)
        armor_rect = pygame.Rect(205, 280, 220, 80)
        if mouse_clicked and crafting_ui_area.collidepoint(mouse_pos) and not crafting_ui.visible:
            print("Craft pressed")
            crafting_ui.visible = True
                        
        if crafting_ui.visible:
            crafting_ui.draw(screen)
            # Close button logic (circle at (435, 115), radius 15)
            close_center = (435, 115)
            close_radius = 15
            dx = mouse_pos[0] - close_center[0]
            dy = mouse_pos[1] - close_center[1]
            # Check if click is inside the circle
            if mouse_clicked and dx*dx + dy*dy <= close_radius*close_radius:
                if crafting_ui.visible:
                    print("Closed crafting UI")
                    crafting_ui.visible = False  
            if mouse_clicked and boat_rect.collidepoint(mouse_pos) and not boat_ui.visible:                
                print("Boat pressed")
                boat_ui.visible = True
                armor_ui.visible = False
                crafting_ui.visible = False
            elif mouse_clicked and armor_rect.collidepoint(mouse_pos) and not armor_ui.visible:
                print("Armor pressed")
                armor_ui.visible = True
                boat_ui.visible = False
                crafting_ui.visible = False
 
        
        if boat_ui.visible:
            boat_ui.handle_event(event)
            boat_ui.draw(screen)
            if mouse_clicked: 
                if boat_ui.close_button.collidepoint(mouse_pos):
                    boat_ui.visible = False  # Close the boat UI
                elif boat_ui.add_button.collidepoint(mouse_pos):
                    # Try to add materials
                    boat_ui.try_add_materials()
                    
        elif armor_ui.visible:
            armor_ui.draw(screen)
            if mouse_clicked:
                if armor_ui.close_button.collidepoint(mouse_pos):
                    print("Closed armor ui")
                    armor_ui.visible = False
                    if boat_ui.wood >= boat_ui.max_wood and boat_ui.crystal >= boat_ui.max_crystal:
                        boat_built = True
                        
        if boss.is_dead:
            boss_defeated = True
            
        # Show mouse position on screen
        #mouse_pos_text = font.render(f"Mouse: {mouse_x}, {mouse_y}", True, (255, 255, 255))
        #screen.blit(mouse_pos_text, (10, 10))

    boat_ui.save_progress()

    if game_state == "achievements":
        achievement_page.visible = True
        achievement_page.draw(screen)
    else:
        achievement_page.visible = False     
    achievement_display.update()
    
    # Check if it's time to show escape UI
    if boat_built and boss_defeated and not escape_ui_triggered:
        show_escape_ui = True
        escape_ui_triggered = True

    # -------- ESCAPE UI (MESSAGE + BUTTON) --------
    if show_escape_ui and not playing_boat_animation:
        # Draw message
        escape_font = pygame.font.SysFont(None, 60)  # Larger title font
        escape_text = escape_font.render("You can escape the Pawland!", True, (255, 255, 255))
        screen.blit(escape_text, (screen.get_width() // 2 - escape_text.get_width() // 2, 140))

        # Draw button
        button_rect = pygame.Rect(screen.get_width() // 2 - 75, 250, 180, 50)
        pygame.draw.rect(screen, (255, 0, 0), button_rect, border_radius=10)
        btn_font = pygame.font.SysFont(None, 30)
        btn_text = btn_font.render("Ride boat", True, (255, 255, 255))
        screen.blit(btn_text, (button_rect.centerx - btn_text.get_width() // 2.1, button_rect.centery - btn_text.get_height() // 2))

        # Handle button click
        if pygame.mouse.get_pressed()[0]:
            if button_rect.collidepoint(pygame.mouse.get_pos()):
                show_escape_ui = False
                playing_boat_animation = True
                boat_anim_timer = pygame.time.get_ticks()
                current_boat_frame = 0

    # -------- BOAT RIDING ANIMATION --------
    if playing_boat_animation:
        now = pygame.time.get_ticks()
        if now - boat_anim_timer > boat_frame_duration:
            current_boat_frame += 1
            boat_anim_timer = now

            if current_boat_frame >= len(boat_riding_frames):
                current_boat_frame = len(boat_riding_frames) - 1
                playing_boat_animation = False
                show_the_end_screen = True

        # Draw boat animation frame
        frame = boat_riding_frames[current_boat_frame]
        screen.blit(frame, (screen.get_width() // 2 - frame_width // 2, screen.get_height() // 2 - frame_height // 2))

    # -------- "THE END" SCREEN --------
    if show_the_end_screen:
        screen.fill((0, 0, 0))

        # The End text
        font = pygame.font.SysFont(None, 72)
        end_text = font.render("The End", True, (255, 255, 255))
        screen.blit(end_text, (screen.get_width() // 2 - end_text.get_width() // 2, 150))

        # Quit button
        quit_button_rect = pygame.Rect(screen.get_width() // 2 - 75, 300, 150, 60)
        pygame.draw.rect(screen, (200, 50, 50), quit_button_rect, border_radius=12)
        quit_font = pygame.font.SysFont(None, 40)
        quit_text = quit_font.render("Quit", True, (255, 255, 255))
        screen.blit(quit_text, (quit_button_rect.centerx - quit_text.get_width() // 2, quit_button_rect.centery - quit_text.get_height() // 2))

        # Quit button click
        if pygame.mouse.get_pressed()[0]:
            if quit_button_rect.collidepoint(pygame.mouse.get_pos()):
                pygame.quit()
                sys.exit()


    pygame.display.update()
    pygame.display.flip()
pygame.quit()
sys.exit()