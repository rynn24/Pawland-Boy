import pygame
import math
import sys
import random
import time

# Initialize
pygame.init()
screen = pygame.display.set_mode((640, 480))
pygame.display.set_caption("Pawland Boy")
clock = pygame.time.Clock()

# Load images
map_image = pygame.image.load("map/Map.png").convert()
walk_down = [pygame.image.load("minting/down1.png"), pygame.image.load("minting/down2.png")]
walk_up = [pygame.image.load("minting/up1.png"), pygame.image.load("minting/up2.png")]
walk_left = [pygame.image.load("minting/L1.png"), pygame.image.load("minting/L2.png")]
walk_right = [pygame.image.load("minting/R0.png"), pygame.image.load("minting/R1.png")]
zombie_img = pygame.image.load("haojun/image/zombie.png").convert_alpha()  # <--- STEP 1
zombie_img = pygame.transform.scale(zombie_img, (64, 64))
zombie_walk_images = [
    pygame.transform.scale(pygame.image.load("haojun/image/zombiewalk1.png").convert_alpha(), (64, 64)),
    pygame.transform.scale(pygame.image.load("haojun/image/zombiewalk2.png").convert_alpha(), (64, 64)),
    pygame.transform.scale(pygame.image.load("haojun/image/zombiewalk3.png").convert_alpha(), (64, 64)),
    pygame.transform.scale(pygame.image.load("haojun/image/zombiewalk4.png").convert_alpha(), (64, 64)),
    pygame.transform.scale(pygame.image.load("haojun/image/zombiewalk5.png").convert_alpha(), (64, 64)),
]

#See coordinates *TESTING
font = pygame.font.SysFont(None, 24)  # Default font, size 24
class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.position = pygame.Vector2(x, y)
        self.health = 100
        self.last_attack_time = 0
        self.attack_cooldown = 1
        self.speed = 2
        self.direction = 'down'
        self.moving = False
        self.frame = 0
        self.anim_timer = 0
        self.frame_delay = 0.2
        self.sprite_sets = {
            'down': walk_down,
            'up': walk_up,
            'left': walk_left,
            'right': walk_right,
        }

    def update(self, keys, dt, map_image, restricted_zones):
        move_distance = self.speed * dt * 60
        self.moving = False
        if keys[pygame.K_a]:
            self.position.x -= move_distance
            self.direction = 'left'
            self.moving = True
        elif keys[pygame.K_d]:
            self.position.x += move_distance
            self.direction = 'right'
            self.moving = True
        elif keys[pygame.K_w]:
            self.position.y -= move_distance
            self.direction = 'up'
            self.moving = True
        elif keys[pygame.K_s]:
            self.position.y += move_distance
            self.direction = 'down'
            self.moving = True

        self.position.x = max(0, min(self.position.x, map_image.get_width()))
        self.position.y = max(0, min(self.position.y, map_image.get_height()))

        if self.moving:
            self.anim_timer += dt
            if self.anim_timer >= self.frame_delay:
                self.frame = (self.frame + 1) % 2
                self.anim_timer = 0
        else:
            self.frame = 0

    def get_sprite(self):
        return self.sprite_sets[self.direction][self.frame]

    def can_attack(self):
        return time.time() - self.last_attack_time >= self.attack_cooldown

    def take_damage(self, amount):
        self.health = max(0, self.health - amount)

    def draw_health_bar(self, surface):
        bar_width = 200
        bar_height = 20
        fill = (self.health / 100) * bar_width
        x = (surface.get_width() - bar_width) // 2
        y = 570
        pygame.draw.rect(surface, (255, 0, 0), (x, y, bar_width, bar_height))
        pygame.draw.rect(surface, (0, 255, 0), (x, y, fill, bar_height))
        pygame.draw.rect(surface, (255, 255, 255), (x, y, bar_width, bar_height), 2)

# Zombie class
class Zombie(pygame.sprite.Sprite):
    def __init__(self, x, y, player):
        super().__init__()
        self.image = zombie_img.copy()  # <--- STEP 2
        self.idle_image = zombie_img.copy()  # This is the original image as idle frame
        self.image = self.idle_image
        self.rect = self.image.get_rect(center=(x, y))#handle collision detection and positioning.
        self.player = player#build a link between player and the zombie, the zombie can get the info of the player(coordinate of the player)
        self.speed = 1.5
        self.attack_range = 32
        self.attack_damage = 10
        self.last_attack_time = 0
        self.attack_cooldown = 1
        self.hp = 50
        self.max_hp = 50
        self.is_moving = False  # Track if zombie is actually moving
        self.walk_images = zombie_walk_images
        self.image = self.walk_images[0]#set the zombie to the 1st walking frame
        self.rect = self.image.get_rect(center=(x, y))
        self.animation_index = 0
        self.last_animation_time = time.time()
        self.animation_speed = 0.2  # Seconds between frames

        # Wandering
        self.is_wandering = True#need more explaination
        self.wander_direction = [random.uniform(-1, 1), random.uniform(-1, 1)]#the zombie can moving left right or up and down
        self.last_wander_time = time.time()#how long since last wander
        self.wander_interval = 2#how long should zombie wander
        self.pause_duration = 2#stop 2s after wandering

    def update(self):
        current_time = time.time()
        dx = self.player.rect.x - self.rect.x
        dy = self.player.rect.y - self.rect.y
        dist = math.hypot(dx, dy)#hypothenuse

        chase_range = 200

        if dist < chase_range:
            if dist == 0:
                dist = 1#avoid 0 division
            dx, dy = dx / dist, dy / dist#let the zombie have consistent speed

            if current_time - self.last_attack_time >= self.attack_cooldown:
                self.rect.x += dx * self.speed
                self.rect.y += dy * self.speed
                self.is_moving = True
            else:
                self.is_moving = False

            if dist < self.attack_range and current_time - self.last_attack_time >= self.attack_cooldown:
                self.attack_player()
        else:
            if self.is_wandering:
                self.rect.x += self.wander_direction[0] * self.speed * 0.5#this is for x
                self.rect.y += self.wander_direction[1] * self.speed * 0.5#this is for y
                self.is_moving = True


                if current_time - self.last_wander_time > self.wander_interval:#if the zombie have wander for 2s then stop
                    self.is_wandering = False
                    self.last_wander_time = current_time
            else:
                self.is_moving = False
                if current_time - self.last_wander_time > self.pause_duration:
                    self.is_wandering = True
                    self.last_wander_time = current_time
                    self.wander_direction = [random.uniform(-1, 1), random.uniform(-1, 1)]
                    length = math.hypot(*self.wander_direction)
                    if length != 0:
                        self.wander_direction[0] /= length
                        self.wander_direction[1] /= length#repeat the code again to let the zombie change the direction

        if self.is_moving:
            if time.time() - self.last_animation_time > self.animation_speed:
                self.animation_index = (self.animation_index + 1) % len(self.walk_images)
                self.image = self.walk_images[self.animation_index]
                self.last_animation_time = time.time()
        else:
            self.image = self.idle_image # Show idle frame

    def attack_player(self):
        self.player.take_damage(self.attack_damage)
        self.last_attack_time = time.time()
        print("Zombie attacks!")

    def take_damage(self, amount, attacker_pos=None):
        self.hp -= amount
        print(f"Zombie HP: {self.hp}")

        if attacker_pos is not None:#check the attacker position
            dx = self.rect.centerx - attacker_pos[0]
            dy = self.rect.centery - attacker_pos[1]
            dist = math.hypot(dx, dy)
            if dist != 0:
                dx /= dist
                dy /= dist
                knockback_distance = 20
                self.rect.x += dx * knockback_distance
                self.rect.y += dy * knockback_distance

        if self.hp <= 0:
            print("Zombie died!")
            self.kill()#attribute of sprite

    def draw_health_bar(self, surface):
        bar_width = 30
        bar_height = 5
        fill = (self.hp / self.max_hp) * bar_width
        x = self.rect.centerx - bar_width // 2
        y = self.rect.top - 10
        pygame.draw.rect(surface, (255, 0, 0), (x, y, bar_width, bar_height))
        pygame.draw.rect(surface, (0, 255, 0), (x, y, fill, bar_height))

player = Player(x=400, y=300)  # Set the initial position for the player
all_sprites = pygame.sprite.Group()
zombie_group = pygame.sprite.Group()
all_sprites.add(player)



# Settings
camera_width, camera_height = 300, 180
camera = pygame.Rect(0, 0, camera_width, camera_height)
zoom_surface = pygame.Surface((camera_width, camera_height))
player = Player(320, 180)
speed = 2
restricted_zones = [
    
]

# Day-night overlay
overlay = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
time_counter = 0
cycle_speed = (2 * math.pi) / 30  # 30 seconds

# Minimap
minimap_radius = 80
minimap_pos = (minimap_radius + 10, minimap_radius + 10)
minimap_zoom_factor = 0.5
minimap_mask = pygame.Surface((minimap_radius*2, minimap_radius*2), pygame.SRCALPHA)
pygame.draw.circle(minimap_mask, (255, 255, 255), (minimap_radius, minimap_radius), minimap_radius)

# Player animation
direction = 'down'
moving = False
frame = 0
anim_timer = 0
frame_delay = 0.2  # seconds per frame

# Game loop
running = True
while running:
    dt = clock.tick(60) / 1000

    # Events
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_EQUALS:
                minimap_zoom_factor = min(4.0, minimap_zoom_factor + 0.1)
            elif event.key == pygame.K_MINUS:
                minimap_zoom_factor = max(0.5, minimap_zoom_factor - 0.1)

    # Movement
    keys = pygame.key.get_pressed()
    player.update(keys, dt,map_image, restricted_zones)


    # Bounds & restrictions
    player.update(pygame.key.get_pressed(), dt, map_image, restricted_zones)

    # Animation
    if moving:
        anim_timer += dt
        if anim_timer >= frame_delay:
            frame = (frame + 1) % 2
            anim_timer = 0
    else:
        frame = 0  # idle frame

    # Select sprite
    if direction == 'down':
        sprite = walk_down[frame]
    elif direction == 'up':
        sprite = walk_up[frame]
    elif direction == 'left':
        sprite = walk_left[frame]
    elif direction == 'right':
        sprite = walk_right[frame]

    # Camera
    camera.center = player.position
    camera.clamp_ip(map_image.get_rect())

    # World render
    zoom_surface.blit(map_image, (0, 0), camera)
    zoomed_view = pygame.transform.scale(zoom_surface, screen.get_size())
    screen.blit(zoomed_view, (0, 0))

    # Draw player (sprite centered)
    screen.blit(sprite, (screen.get_width()//2 - sprite.get_width()//2,
                         screen.get_height()//2 - sprite.get_height()//2))

    # Minimap
    minimap_surface = pygame.Surface((minimap_radius*2, minimap_radius*2), pygame.SRCALPHA)
    mini_camera_size = minimap_radius * 2 / minimap_zoom_factor
    mini_camera = pygame.Rect(0, 0, mini_camera_size, mini_camera_size)
    mini_camera.center = player.position
    mini_camera.clamp_ip(map_image.get_rect())

    mini_view = map_image.subsurface(mini_camera).copy()
    scaled_mini_view = pygame.transform.scale(mini_view, (minimap_radius * 2, minimap_radius * 2))
    minimap_surface.blit(scaled_mini_view, (0, 0))
    masked_minimap = minimap_surface.copy()
    masked_minimap.blit(minimap_mask, (0, 0), special_flags=pygame.BLEND_RGBA_MULT)
    pygame.draw.circle(masked_minimap, (255, 50, 50), (minimap_radius, minimap_radius), 3)
    pygame.draw.circle(masked_minimap, (0, 0, 0), (minimap_radius, minimap_radius), minimap_radius, 2)
    screen.blit(masked_minimap, (minimap_pos[0] - minimap_radius, minimap_pos[1] - minimap_radius))

    # Day-night cycle
    time_counter += dt
    alpha = int((math.sin(time_counter * cycle_speed) + 1) / 2 * 150)
    overlay.fill((0, 0, 0, alpha))
    screen.blit(overlay, (0, 0))

    # Create the coordinate text *TEST
    coord_text = f"X: {int(player.position.x)}  Y: {int(player.position.y)}"
    text_surface = font.render(coord_text, True, (255, 255, 255))  # White text
    screen.blit(text_surface, (10, screen.get_height() - 30))  # Bottom-left corner

    if keys[pygame.K_SPACE] and player.can_attack():
        for zombie in zombie_group:
            player_rect = pygame.Rect(player.position.x - 16, player.position.y - 16, 32, 32)  # Adjust size as needed
            if player_rect.colliderect(zombie.rect):
                zombie.take_damage(20, player.position)  # Apply damage
                player.last_attack_time = time.time()  # Reset attack cooldown
                break  # Stop after hitting one zombie

    pygame.display.flip()

pygame.quit()
sys.exit()